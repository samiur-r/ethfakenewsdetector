{"ast":null,"code":"import * as React from 'react';\n\nvar isCheckBoxInput = element => element.type === 'checkbox';\n\nvar isNullOrUndefined = value => value == null;\n\nconst isObjectType = value => typeof value === 'object';\n\nvar isObject = value => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !(value instanceof Date);\n\nvar getControllerValue = event => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;\n\nvar getNodeParentName = name => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some(current => getNodeParentName(name) === current);\n\nvar compact = value => value.filter(Boolean);\n\nvar isUndefined = val => val === undefined;\n\nvar get = function () {\n  let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let path = arguments.length > 1 ? arguments[1] : undefined;\n  let defaultValue = arguments.length > 2 ? arguments[2] : undefined;\n  const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\n\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change'\n};\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all'\n};\nconst SELECT = 'select';\nconst UNDEFINED = 'undefined';\nconst INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\n\nvar omit = (source, key) => {\n  const copy = Object.assign({}, source);\n  delete copy[key];\n  return copy;\n};\n\nconst FormContext = React.createContext(null);\nFormContext.displayName = 'RHFContext';\n\nconst useFormContext = () => React.useContext(FormContext);\n\nconst FormProvider = props => React.createElement(FormContext.Provider, {\n  value: omit(props, 'children')\n}, props.children);\n\nvar getProxyFormState = function (isProxyEnabled, formState, readFormStateRef, localReadFormStateRef) {\n  let isRoot = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  return isProxyEnabled ? new Proxy(formState, {\n    get: (obj, prop) => {\n      if (prop in obj) {\n        if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\n          readFormStateRef.current[prop] = isRoot ? VALIDATION_MODE.all : true;\n        }\n\n        localReadFormStateRef && (localReadFormStateRef.current[prop] = true);\n        return obj[prop];\n      }\n\n      return undefined;\n    }\n  }) : formState;\n};\n\nvar isEmptyObject = value => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formState, readFormStateRef, isRoot) => isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(readFormStateRef).length || Object.keys(formState).find(key => readFormStateRef[key] === (isRoot ? VALIDATION_MODE.all : true));\n\nvar isWeb = typeof window !== UNDEFINED && typeof window.HTMLElement !== UNDEFINED && typeof document !== UNDEFINED;\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nfunction useFormState(props) {\n  const methods = useFormContext();\n  const {\n    formStateRef,\n    formStateSubjectRef,\n    readFormStateRef\n  } = props && props.control || methods.control;\n  const [formState, updateFormState] = React.useState(formStateRef.current);\n  const readFormState = React.useRef({\n    isDirty: false,\n    dirtyFields: false,\n    touchedFields: false,\n    isValidating: false,\n    isValid: false,\n    errors: false\n  });\n  React.useEffect(() => {\n    const formStateSubscription = formStateSubjectRef.current.subscribe({\n      next: formState => {\n        shouldRenderFormState(formState, readFormState.current) && updateFormState(Object.assign(Object.assign({}, formStateRef.current), formState));\n      }\n    });\n    return () => formStateSubscription.unsubscribe();\n  }, []);\n  return getProxyFormState(isProxyEnabled, formState, readFormStateRef, readFormState, false);\n}\n\nfunction useController(_ref) {\n  let {\n    name,\n    rules,\n    defaultValue,\n    control\n  } = _ref;\n  const methods = useFormContext();\n  const {\n    defaultValuesRef,\n    register,\n    fieldsRef,\n    fieldArrayNamesRef,\n    controllerSubjectRef\n  } = control || methods.control;\n  const {\n    onChange,\n    onBlur,\n    ref\n  } = register(name, rules);\n  const [value, setInputStateValue] = React.useState(isUndefined(get(fieldsRef.current, name)._f.value) || isNameInFieldArray(fieldArrayNamesRef.current, name) ? isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue : get(fieldsRef.current, name)._f.value);\n  const formState = useFormState({\n    control: control || methods.control\n  });\n  get(fieldsRef.current, name)._f.value = value;\n  React.useEffect(() => {\n    const controllerSubscription = controllerSubjectRef.current.subscribe({\n      next: data => (!data.name || name === data.name) && setInputStateValue(get(data.values, name))\n    });\n    ref({\n      target: value\n    });\n    return () => controllerSubscription.unsubscribe();\n  }, [name]);\n  return {\n    field: {\n      onChange: event => {\n        const value = getControllerValue(event);\n        setInputStateValue(value);\n        onChange({\n          target: {\n            value,\n            name: name\n          },\n          type: EVENTS.CHANGE\n        });\n      },\n      onBlur: () => {\n        onBlur({\n          target: {\n            name: name\n          },\n          type: EVENTS.BLUR\n        });\n      },\n      name,\n      value,\n      ref\n    },\n    formState,\n    fieldState: Object.defineProperties({}, {\n      invalid: {\n        get() {\n          return !!get(formState.errors, name);\n        }\n\n      },\n      isDirty: {\n        get() {\n          return !!get(formState.dirtyFields, name);\n        }\n\n      },\n      isTouched: {\n        get() {\n          return !!get(formState.touchedFields, name);\n        }\n\n      },\n      error: {\n        get() {\n          return get(formState.errors, name);\n        }\n\n      }\n    })\n  };\n}\n\nconst Controller = props => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? Object.assign(Object.assign({}, errors[name]), {\n  types: Object.assign(Object.assign({}, errors[name] && errors[name].types ? errors[name].types : {}), {\n    [type]: message || true\n  })\n}) : {};\n\nvar isKey = value => /^\\w*$/.test(value);\n\nvar stringToPath = input => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\n  for (const key of fieldsNames || Object.keys(fields)) {\n    const field = get(fields, key);\n\n    if (field) {\n      const _f = field._f;\n      const current = omit(field, '_f');\n\n      if (_f && callback(_f.name)) {\n        if (_f.ref.focus && isUndefined(_f.ref.focus())) {\n          break;\n        } else if (_f.refs) {\n          _f.refs[0].focus();\n\n          break;\n        }\n      } else if (isObject(current)) {\n        focusFieldBy(current, callback);\n      }\n    }\n  }\n};\n\nconst getFieldsValues = function (fieldsRef) {\n  let defaultValuesRef = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    current: {}\n  };\n  let output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  for (const name in fieldsRef.current) {\n    const field = fieldsRef.current[name];\n\n    if (field) {\n      const _f = field._f;\n      const current = omit(field, '_f');\n      set(output, name, _f ? _f.ref.disabled || _f.refs && _f.refs.every(ref => ref.disabled) ? undefined : _f.value : Array.isArray(field) ? [] : {});\n\n      if (current) {\n        getFieldsValues({\n          current\n        }, defaultValuesRef, output[name]);\n      }\n    }\n  }\n\n  return Object.assign(Object.assign({}, defaultValuesRef.current), output);\n};\n\nvar generateId = () => {\n  const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nvar mapIds = function () {\n  let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let keyName = arguments.length > 1 ? arguments[1] : undefined;\n  return values.map(value => Object.assign({\n    [keyName]: value && value[keyName] || generateId()\n  }, value));\n};\n\nvar isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2, isErrorObject) {\n  if (isPrimitive(object1) || isPrimitive(object2) || object1 instanceof Date || object2 instanceof Date) {\n    return object1 === object2;\n  }\n\n  if (!React.isValidElement(object1)) {\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (const key of keys1) {\n      const val1 = object1[key];\n\n      if (!(isErrorObject && key === 'ref')) {\n        const val2 = object2[key];\n\n        if ((isObject(val1) || Array.isArray(val1)) && (isObject(val2) || Array.isArray(val2)) ? !deepEqual(val1, val2, isErrorObject) : val1 !== val2) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction deepMerge(target, source) {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] = isObject(targetValue) && isObject(sourceValue) || Array.isArray(targetValue) && Array.isArray(sourceValue) ? deepMerge(targetValue, sourceValue) : sourceValue;\n    } catch (_a) {}\n  }\n\n  return target;\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\n      } else {\n        deepEqual(get(defaultValues[index] || {}, key), values[index][key]) ? set(dirtyFields[index] || {}, key) : dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), {\n          [key]: true\n        });\n      }\n    }\n\n    parentNode && !dirtyFields.length && delete parentNode[parentName];\n  }\n\n  return dirtyFields;\n}\n\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nfunction append(data, value) {\n  return [...data, ...(Array.isArray(value) ? value : [value])];\n}\n\nvar fillEmptyArray = value => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction insert(data, index, value) {\n  return [...data.slice(0, index), ...(Array.isArray(value) ? value : [value]), ...data.slice(index)];\n}\n\nvar moveArrayAt = (data, from, to) => {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n\nfunction prepend(data, value) {\n  return [...(Array.isArray(value) ? value : [value]), ...data];\n}\n\nfunction removeAtIndexes(data, indexes) {\n  let i = 0;\n  const temp = [...data];\n\n  for (const index of indexes) {\n    temp.splice(index - i, 1);\n    i++;\n  }\n\n  return compact(temp).length ? temp : [];\n}\n\nvar removeArrayAt = (data, index) => isUndefined(index) ? [] : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\n  data[indexA] = [data[indexB], data[indexB] = data[indexA]][0];\n};\n\nvar isBoolean = value => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\n  const length = updatePath.slice(0, -1).length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nfunction unset(object, path) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || Array.isArray(objectRef) && !objectRef.filter(data => isObject(data) && !isEmptyObject(data) || isBoolean(data)).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nconst useFieldArray = _ref2 => {\n  let {\n    control,\n    name,\n    keyName = 'id'\n  } = _ref2;\n  const methods = useFormContext();\n  const focusNameRef = React.useRef('');\n  const {\n    isWatchAllRef,\n    watchFieldsRef,\n    getFormIsDirty,\n    watchSubjectRef,\n    fieldArraySubjectRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    formStateRef,\n    formStateSubjectRef,\n    readFormStateRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef\n  } = control || methods.control;\n  const [fields, setFields] = React.useState(mapIds(get(fieldArrayDefaultValuesRef.current, getNodeParentName(name)) ? get(fieldArrayDefaultValuesRef.current, name, []) : get(defaultValuesRef.current, name, []), keyName));\n  set(fieldArrayDefaultValuesRef.current, name, [...fields]);\n  fieldArrayNamesRef.current.add(name);\n\n  const omitKey = fields => fields.map(field => omit(field || {}, keyName));\n\n  const getCurrentFieldsValues = () => {\n    const values = get(getFieldsValues(fieldsRef, defaultValuesRef), name, []);\n    return mapIds(get(fieldArrayDefaultValuesRef.current, name, []).map((item, index) => Object.assign(Object.assign({}, item), values[index])), keyName);\n  };\n\n  const getFocusDetail = (index, options) => options ? !isUndefined(options.focusIndex) ? `${name}.${options.focusIndex}` : options.focusName ? options.focusName : !options.shouldFocus ? '' : `${name}.${index}` : `${name}.${index}`;\n\n  const resetFields = index => (Array.isArray(index) ? index : [index]).forEach(currentIndex => set(fieldsRef.current, `${name}${isUndefined(currentIndex) ? '' : `.${currentIndex}`}`, isUndefined(currentIndex) ? [] : undefined));\n\n  const setFieldsAndNotify = function () {\n    let fieldsValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    return setFields(mapIds(fieldsValues, keyName));\n  };\n\n  const cleanup = ref => !compact(get(ref, name, [])).length && unset(ref, name);\n\n  const updateDirtyFieldsWithDefaultValues = updatedFieldArrayValues => updatedFieldArrayValues && set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n\n  const batchStateUpdate = function (method, args) {\n    let updatedFieldArrayValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let shouldSet = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (get(fieldsRef.current, name)) {\n      const output = method(get(fieldsRef.current, name), args.argA, args.argB);\n      shouldSet && set(fieldsRef.current, name, output);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (readFormStateRef.current.touchedFields && get(formStateRef.current.touchedFields, name)) {\n      const output = method(get(formStateRef.current.touchedFields, name), args.argA, args.argB);\n      shouldSet && set(formStateRef.current.touchedFields, name, output);\n      cleanup(formStateRef.current.touchedFields);\n    }\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n      updateDirtyFieldsWithDefaultValues(updatedFieldArrayValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (readFormStateRef.current.isValid) {\n      set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\n      cleanup(validFieldsRef.current);\n      set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    formStateSubjectRef.current.next({\n      isDirty: getFormIsDirty(name, omitKey(updatedFieldArrayValues)),\n      errors: formStateRef.current.errors,\n      isValid: formStateRef.current.isValid\n    });\n  };\n\n  const registerFieldArray = function (values) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let parentName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    return values.forEach((appendValueItem, valueIndex) => !isPrimitive(appendValueItem) && Object.entries(appendValueItem).forEach(_ref3 => {\n      let [key, value] = _ref3;\n      const inputName = `${parentName || name}.${parentName ? valueIndex : index + valueIndex}.${key}`;\n      Array.isArray(value) ? registerFieldArray(value, valueIndex, inputName) : set(fieldsRef.current, inputName, {\n        _f: {\n          ref: {\n            name: inputName\n          },\n          name: inputName,\n          value\n        }\n      });\n    }));\n  };\n\n  const append$1 = (value, options) => {\n    const appendValue = Array.isArray(value) ? value : [value];\n    const updatedFieldArrayValues = append(getCurrentFieldsValues(), appendValue);\n    const currentIndex = updatedFieldArrayValues.length - appendValue.length;\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(append, {\n      argA: fillEmptyArray(value)\n    }, updatedFieldArrayValues, false);\n    registerFieldArray(appendValue, currentIndex);\n    focusNameRef.current = getFocusDetail(currentIndex, options);\n  };\n\n  const prepend$1 = (value, options) => {\n    const prependValue = Array.isArray(value) ? value : [value];\n    const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), prependValue);\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(prepend, {\n      argA: fillEmptyArray(value)\n    }, updatedFieldArrayValues);\n    registerFieldArray(prependValue);\n    focusNameRef.current = getFocusDetail(0, options);\n  };\n\n  const remove = index => {\n    const updatedFieldArrayValues = removeArrayAt(getCurrentFieldsValues(), index);\n    resetFields(index);\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(removeArrayAt, {\n      argA: index\n    }, updatedFieldArrayValues);\n  };\n\n  const insert$1 = (index, value, options) => {\n    const insertValue = Array.isArray(value) ? value : [value];\n    const updatedFieldArrayValues = insert(getCurrentFieldsValues(), index, insertValue);\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(insert, {\n      argA: index,\n      argB: fillEmptyArray(value)\n    }, updatedFieldArrayValues);\n    registerFieldArray(insertValue, index);\n    focusNameRef.current = getFocusDetail(index, options);\n  };\n\n  const swap = (indexA, indexB) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    batchStateUpdate(swapArrayAt, {\n      argA: indexA,\n      argB: indexB\n    }, fieldValues, false);\n    setFieldsAndNotify(fieldValues);\n  };\n\n  const move = (from, to) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    setFieldsAndNotify(fieldValues);\n    batchStateUpdate(moveArrayAt, {\n      argA: from,\n      argB: to\n    }, fieldValues, false);\n  };\n\n  React.useEffect(() => {\n    if (isWatchAllRef.current) {\n      formStateSubjectRef.current.next({});\n    } else {\n      for (const watchField of watchFieldsRef.current) {\n        if (name.startsWith(watchField)) {\n          formStateSubjectRef.current.next({});\n          break;\n        }\n      }\n    }\n\n    watchSubjectRef.current.next({\n      name,\n      value: get(getFieldsValues(fieldsRef, defaultValuesRef), name, [])\n    });\n    focusNameRef.current && focusFieldBy(fieldsRef.current, key => key.startsWith(focusNameRef.current));\n    focusNameRef.current = '';\n    fieldArraySubjectRef.current.next({\n      name,\n      fields: omitKey([...fields])\n    });\n  }, [fields, name]);\n  React.useEffect(() => {\n    const fieldArraySubscription = fieldArraySubjectRef.current.subscribe({\n      next(_ref4) {\n        let {\n          name: inputFieldArrayName,\n          fields,\n          isReset\n        } = _ref4;\n\n        if (isReset) {\n          unset(fieldsRef.current, inputFieldArrayName || name);\n          inputFieldArrayName ? set(fieldArrayDefaultValuesRef.current, inputFieldArrayName, fields) : fieldArrayDefaultValuesRef.current = fields;\n          setFieldsAndNotify(get(fieldArrayDefaultValuesRef.current, name));\n        }\n      }\n\n    });\n    !get(fieldsRef.current, name) && set(fieldsRef.current, name, []);\n    return () => {\n      fieldArrayDefaultValuesRef.current = getFieldsValues(fieldsRef);\n      fieldArraySubscription.unsubscribe();\n    };\n  }, []);\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend$1, [name]),\n    append: React.useCallback(append$1, [name]),\n    remove: React.useCallback(remove, [name]),\n    insert: React.useCallback(insert$1, [name]),\n    fields: fields\n  };\n};\n\nfunction getFields(fieldsNames, fieldsRefs) {\n  const currentFields = {};\n\n  for (const name of fieldsNames) {\n    const field = get(fieldsRefs, name);\n\n    if (field) {\n      !isKey(name) ? set(currentFields, name, field._f) : currentFields[name] = field._f;\n    }\n  }\n\n  return currentFields;\n}\n\nvar isFileInput = element => element.type === 'file';\n\nvar isMultipleSelect = element => element.type === `${SELECT}-multiple`;\n\nvar isRadioInput = element => element.type === 'radio';\n\nconst defaultResult = {\n  value: false,\n  isValid: false\n};\nconst validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = options => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options.filter(option => option && option.checked && !option.disabled).map(option => option.value);\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    return options[0].checked && !options[0].disabled ? // @ts-expect-error expected to work in the browser\n    options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === '' ? validResult : {\n      value: options[0].value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nvar getFieldValueAs = (value, _ref5) => {\n  let {\n    valueAsNumber,\n    valueAsDate,\n    setValueAs\n  } = _ref5;\n  return valueAsNumber ? value === '' ? NaN : +value : valueAsDate ? new Date(value) : setValueAs ? setValueAs(value) : value;\n};\n\nvar getMultipleSelectValue = options => [...options].filter(_ref6 => {\n  let {\n    selected\n  } = _ref6;\n  return selected;\n}).map(_ref7 => {\n  let {\n    value\n  } = _ref7;\n  return value;\n});\n\nconst defaultReturn = {\n  isValid: false,\n  value: null\n};\n\nvar getRadioValue = options => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {\n  isValid: true,\n  value: option.value\n} : previous, defaultReturn) : defaultReturn;\n\nfunction getFieldValue(field) {\n  if (field && field._f) {\n    const ref = field._f.ref;\n\n    if (ref.disabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field._f.refs).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return getCheckboxValue(field._f.refs).value;\n    }\n\n    return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\n  }\n}\n\nvar skipValidation = _ref8 => {\n  let {\n    isOnBlur,\n    isOnChange,\n    isOnTouch,\n    isTouched,\n    isReValidateOnBlur,\n    isReValidateOnChange,\n    isBlurEvent,\n    isSubmitted,\n    isOnAll\n  } = _ref8;\n\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n\n  return true;\n};\n\nvar isFunction = value => typeof value === 'function';\n\nvar isString = value => typeof value === 'string';\n\nvar isMessage = value => isString(value) || React.isValidElement(value);\n\nvar isRegex = value => value instanceof RegExp;\n\nfunction getValidateError(result, ref) {\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'validate';\n\n  if (isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref\n    };\n  }\n}\n\nvar getValueAndMessage = validationData => isObject(validationData) && !isRegex(validationData) ? validationData : {\n  value: validationData,\n  message: ''\n};\n\nvar validateField = async (_ref9, validateAllFieldCriteria) => {\n  let {\n    _f: {\n      ref,\n      refs,\n      required,\n      maxLength,\n      minLength,\n      min,\n      max,\n      pattern,\n      validate,\n      name,\n      value: inputValue,\n      valueAsNumber\n    }\n  } = _ref9;\n  const error = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = (valueAsNumber || isFileInput(ref)) && !ref.value || inputValue === '' || Array.isArray(inputValue) && !inputValue.length;\n  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n  const getMinMaxMessage = function (exceedMax, maxLengthMessage, minLengthMessage) {\n    let maxType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INPUT_VALIDATION_RULES.maxLength;\n    let minType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : INPUT_VALIDATION_RULES.minLength;\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = Object.assign({\n      type: exceedMax ? maxType : minType,\n      message,\n      ref\n    }, appendErrorsCurry(exceedMax ? maxType : minType, message));\n  };\n\n  if (required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {\n    const {\n      value,\n      message\n    } = isMessage(required) ? {\n      value: !!required,\n      message: required\n    } : getValueAndMessage(required);\n\n    if (value) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.required,\n        message,\n        ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) && inputValue !== '') {\n    let exceedMax;\n    let exceedMin;\n    const maxOutput = getValueAndMessage(max);\n    const minOutput = getValueAndMessage(min);\n\n    if (!isNaN(inputValue)) {\n      const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\n\n      if (!isNullOrUndefined(maxOutput.value)) {\n        exceedMax = valueNumber > maxOutput.value;\n      }\n\n      if (!isNullOrUndefined(minOutput.value)) {\n        exceedMin = valueNumber < minOutput.value;\n      }\n    } else {\n      const valueDate = ref.valueAsDate || new Date(inputValue);\n\n      if (isString(maxOutput.value)) {\n        exceedMax = valueDate > new Date(maxOutput.value);\n      }\n\n      if (isString(minOutput.value)) {\n        exceedMin = valueDate < new Date(minOutput.value);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {\n    const maxLengthOutput = getValueAndMessage(maxLength);\n    const minLengthOutput = getValueAndMessage(minLength);\n    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > maxLengthOutput.value;\n    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < minLengthOutput.value;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(inputValue) && pattern && !isEmpty) {\n    const {\n      value: patternValue,\n      message\n    } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !patternValue.test(inputValue)) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.pattern,\n        message,\n        ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(inputValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {};\n\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(inputValue);\n        const validateError = getValidateError(validateResult, validateRef, key);\n\n        if (validateError) {\n          validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = Object.assign({\n          ref: validateRef\n        }, validationResult);\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n\nvar getValidationModes = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched\n});\n\nvar isHTMLElement = value => value instanceof HTMLElement;\n\nvar isRadioOrCheckboxFunction = ref => isRadioInput(ref) || isCheckBoxInput(ref);\n\nclass Subscription {\n  constructor() {\n    this.tearDowns = [];\n  }\n\n  add(tearDown) {\n    this.tearDowns.push(tearDown);\n  }\n\n  unsubscribe() {\n    for (const teardown of this.tearDowns) {\n      teardown();\n    }\n\n    this.tearDowns = [];\n  }\n\n}\n\nclass Subscriber {\n  constructor(observer, subscription) {\n    this.observer = observer;\n    this.closed = false;\n    subscription.add(() => this.closed = true);\n  }\n\n  next(value) {\n    if (!this.closed) {\n      this.observer.next(value);\n    }\n  }\n\n}\n\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n\n  next(value) {\n    for (const observer of this.observers) {\n      observer.next(value);\n    }\n  }\n\n  subscribe(observer) {\n    const subscription = new Subscription();\n    const subscriber = new Subscriber(observer, subscription);\n    this.observers.push(subscriber);\n    return subscription;\n  }\n\n  unsubscribe() {\n    this.observers = [];\n  }\n\n}\n\nconst isWindowUndefined = typeof window === UNDEFINED;\n\nfunction useForm() {\n  let {\n    mode = VALIDATION_MODE.onSubmit,\n    reValidateMode = VALIDATION_MODE.onChange,\n    resolver,\n    context,\n    defaultValues = {},\n    shouldFocusError = true,\n    criteriaMode\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const fieldsRef = React.useRef({});\n  const fieldsNamesRef = React.useRef(new Set());\n  const formStateSubjectRef = React.useRef(new Subject());\n  const watchSubjectRef = React.useRef(new Subject());\n  const controllerSubjectRef = React.useRef(new Subject());\n  const fieldArraySubjectRef = React.useRef(new Subject());\n  const fieldArrayDefaultValuesRef = React.useRef({});\n  const watchFieldsRef = React.useRef(new Set());\n  const isMountedRef = React.useRef(false);\n  const fieldsWithValidationRef = React.useRef({});\n  const validFieldsRef = React.useRef({});\n  const defaultValuesRef = React.useRef(defaultValues);\n  const isWatchAllRef = React.useRef(false);\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef(new Set());\n  const validationMode = getValidationModes(mode);\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = React.useState({\n    isDirty: false,\n    isValidating: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touchedFields: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !validationMode.isOnSubmit,\n    errors: {}\n  });\n  const readFormStateRef = React.useRef({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touchedFields: !isProxyEnabled,\n    isValidating: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n    errors: !isProxyEnabled\n  });\n  const formStateRef = React.useRef(formState);\n  contextRef.current = context;\n  resolverRef.current = resolver;\n\n  const getIsValid = () => formStateRef.current.isValid = deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) && isEmptyObject(formStateRef.current.errors);\n\n  const shouldRenderBaseOnError = React.useCallback(function (name, error) {\n    let shouldRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let isValid = arguments.length > 4 ? arguments[4] : undefined;\n    let isWatched = arguments.length > 5 ? arguments[5] : undefined;\n    const previousError = get(formStateRef.current.errors, name);\n    let shouldReRender = shouldRender || !deepEqual(previousError, error, true) || readFormStateRef.current.isValid && isUndefined(error) && get(fieldsWithValidationRef.current, name) && !get(validFieldsRef.current, name);\n\n    if (error) {\n      unset(validFieldsRef.current, name);\n      shouldReRender = shouldReRender || !previousError || !deepEqual(previousError, error, true);\n      set(formStateRef.current.errors, name, error);\n    } else {\n      if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n        set(validFieldsRef.current, name, true);\n        shouldReRender = shouldReRender || previousError;\n      }\n\n      unset(formStateRef.current.errors, name);\n    }\n\n    if (shouldReRender && !isNullOrUndefined(shouldRender) || !isEmptyObject(state) || isWatched) {\n      const updatedFormState = Object.assign(Object.assign({}, state), {\n        isValid: resolverRef.current ? !!isValid : getIsValid(),\n        errors: formStateRef.current.errors\n      });\n      formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), updatedFormState);\n      formStateSubjectRef.current.next(isWatched ? {} : updatedFormState);\n    }\n\n    formStateSubjectRef.current.next({\n      isValidating: false\n    });\n  }, []);\n  const setFieldValue = React.useCallback(function (name, rawValue) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let shouldRender = arguments.length > 3 ? arguments[3] : undefined;\n    let shouldRegister = arguments.length > 4 ? arguments[4] : undefined;\n    shouldRegister && register(name);\n\n    const _f = get(fieldsRef.current, name, {})._f;\n\n    if (_f) {\n      const value = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n      _f.value = rawValue;\n\n      if (isRadioInput(_f.ref)) {\n        (_f.refs || []).forEach(radioRef => radioRef.checked = radioRef.value === value);\n      } else if (isFileInput(_f.ref) && !isString(value)) {\n        _f.ref.files = value;\n      } else if (isMultipleSelect(_f.ref)) {\n        [..._f.ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n      } else if (isCheckBoxInput(_f.ref) && _f.refs) {\n        _f.refs.length > 1 ? _f.refs.forEach(checkboxRef => checkboxRef.checked = Array.isArray(value) ? !!value.find(data => data === checkboxRef.value) : value === checkboxRef.value) : _f.refs[0].checked = !!value;\n      } else {\n        _f.ref.value = value;\n      }\n\n      if (shouldRender) {\n        const values = getFieldsValues(fieldsRef);\n        set(values, name, rawValue);\n        controllerSubjectRef.current.next({\n          values: Object.assign(Object.assign({}, defaultValuesRef.current), values),\n          name\n        });\n      }\n\n      options.shouldDirty && updateAndGetDirtyState(name, value);\n      options.shouldValidate && trigger(name);\n    }\n  }, []);\n  const getFormIsDirty = React.useCallback((name, data) => {\n    if (readFormStateRef.current.isDirty) {\n      const formValues = getFieldsValues(fieldsRef);\n      name && data && set(formValues, name, data);\n      return !deepEqual(formValues, defaultValuesRef.current);\n    }\n\n    return false;\n  }, []);\n  const updateAndGetDirtyState = React.useCallback(function (name, inputValue) {\n    let shouldRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) {\n      const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), inputValue);\n      const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n      const previousIsDirty = formStateRef.current.isDirty;\n      isFieldDirty ? set(formStateRef.current.dirtyFields, name, true) : unset(formStateRef.current.dirtyFields, name);\n      formStateRef.current.isDirty = getFormIsDirty();\n      const state = {\n        isDirty: formStateRef.current.isDirty,\n        dirtyFields: formStateRef.current.dirtyFields\n      };\n      const isChanged = readFormStateRef.current.isDirty && previousIsDirty !== state.isDirty || readFormStateRef.current.dirtyFields && isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name);\n      isChanged && shouldRender && formStateSubjectRef.current.next(state);\n      return isChanged ? state : {};\n    }\n\n    return {};\n  }, []);\n  const executeValidation = React.useCallback(async (name, skipReRender) => {\n    const error = (await validateField(get(fieldsRef.current, name), isValidateAllFieldCriteria))[name];\n    shouldRenderBaseOnError(name, error, skipReRender);\n    return isUndefined(error);\n  }, [isValidateAllFieldCriteria]);\n  const executeSchemaOrResolverValidation = React.useCallback(async function (names) {\n    let currentNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const {\n      errors\n    } = await resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef), contextRef.current, {\n      criteriaMode,\n      names: currentNames,\n      fields: getFields(fieldsNamesRef.current, fieldsRef.current)\n    });\n\n    for (const name of names) {\n      const error = get(errors, name);\n      error ? set(formStateRef.current.errors, name, error) : unset(formStateRef.current.errors, name);\n    }\n\n    return errors;\n  }, [criteriaMode]);\n\n  const validateForm = async fieldsRef => {\n    for (const name in fieldsRef) {\n      const field = fieldsRef[name];\n\n      if (field) {\n        const _f = field._f;\n        const current = omit(field, '_f');\n\n        if (_f) {\n          const fieldError = await validateField(field, isValidateAllFieldCriteria);\n\n          if (fieldError[_f.name]) {\n            set(formStateRef.current.errors, _f.name, fieldError[_f.name]);\n            unset(validFieldsRef.current, _f.name);\n          } else if (get(fieldsWithValidationRef.current, _f.name)) {\n            set(validFieldsRef.current, _f.name, true);\n            unset(formStateRef.current.errors, _f.name);\n          }\n        }\n\n        current && (await validateForm(current));\n      }\n    }\n  };\n\n  const trigger = React.useCallback(async name => {\n    const fields = isUndefined(name) ? Object.keys(fieldsRef.current) : Array.isArray(name) ? name : [name];\n    let isValid;\n    formStateSubjectRef.current.next({\n      isValidating: true\n    });\n\n    if (resolverRef.current) {\n      isValid = isEmptyObject(await executeSchemaOrResolverValidation(fields, isUndefined(name) ? undefined : fields));\n    } else {\n      isUndefined(name) ? await validateForm(fieldsRef.current) : await Promise.all(fields.map(async data => await executeValidation(data, null)));\n    }\n\n    formStateSubjectRef.current.next({\n      errors: formStateRef.current.errors,\n      isValidating: false,\n      isValid: resolverRef.current ? isValid : getIsValid()\n    });\n  }, [executeSchemaOrResolverValidation, executeValidation]);\n  const setInternalValues = React.useCallback((name, value, options) => Object.entries(value).forEach(_ref10 => {\n    let [inputKey, inputValue] = _ref10;\n    const fieldName = `${name}.${inputKey}`;\n    const field = get(fieldsRef.current, fieldName);\n    field && !field._f ? setInternalValues(fieldName, inputValue, options) : setFieldValue(fieldName, inputValue, options, true, !field);\n  }), [trigger]);\n\n  const isFieldWatched = name => isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const updateValidAndValue = (name, options, isWithinRefCallback) => {\n    let defaultValue;\n    const field = get(fieldsRef.current, name);\n    const useFormDefaultValue = get(defaultValuesRef.current, name);\n\n    if (field && (!isEmptyObject(defaultValuesRef.current) || !isUndefined(field._f.value))) {\n      defaultValue = isUndefined(field._f.value) ? useFormDefaultValue : field._f.value;\n\n      if (!isUndefined(defaultValue)) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    if ((useFormDefaultValue || !useFormDefaultValue && isWithinRefCallback) && options && !validationMode.isOnSubmit && field && readFormStateRef.current.isValid) {\n      validateField(field, isValidateAllFieldCriteria).then(error => {\n        isEmptyObject(error) ? set(validFieldsRef.current, name, true) : unset(validFieldsRef.current, name);\n        formStateRef.current.isValid && !isEmptyObject(error) && setFormState(Object.assign(Object.assign({}, formStateRef.current), {\n          isValid: getIsValid()\n        }));\n      });\n    }\n\n    return defaultValue;\n  };\n\n  const setValue = function (name, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    isMountedRef.current = true;\n    const field = get(fieldsRef.current, name);\n    const isFieldArray = fieldArrayNamesRef.current.has(name);\n\n    if (isFieldArray) {\n      fieldArraySubjectRef.current.next({\n        fields: value,\n        name,\n        isReset: true\n      });\n\n      if ((readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && options.shouldDirty) {\n        set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n        formStateSubjectRef.current.next({\n          dirtyFields: formStateRef.current.dirtyFields,\n          isDirty: getFormIsDirty(name, value)\n        });\n      }\n\n      !value.length && set(fieldsRef.current, name, []) && set(fieldArrayDefaultValuesRef.current, name, []);\n    }\n\n    field && !field._f || isFieldArray ? setInternalValues(name, value, isFieldArray ? {} : options) : setFieldValue(name, value, options, true, !field);\n    isFieldWatched(name) && formStateSubjectRef.current.next({});\n    watchSubjectRef.current.next({\n      name,\n      value\n    });\n  };\n\n  const handleChange = React.useCallback(async _ref11 => {\n    let {\n      type,\n      target,\n      target: {\n        value,\n        type: inputType\n      }\n    } = _ref11;\n    let name = target.name;\n    let error;\n    let isValid;\n    const field = get(fieldsRef.current, name);\n\n    if (field) {\n      const inputValue = inputType ? getFieldValue(field) : value;\n      const isBlurEvent = type === EVENTS.BLUR;\n      const {\n        isOnBlur: isReValidateOnBlur,\n        isOnChange: isReValidateOnChange\n      } = getValidationModes(reValidateMode);\n      const shouldSkipValidation = skipValidation(Object.assign({\n        isBlurEvent,\n        isTouched: !!get(formStateRef.current.touchedFields, name),\n        isSubmitted: formStateRef.current.isSubmitted,\n        isReValidateOnBlur,\n        isReValidateOnChange\n      }, validationMode));\n      const isWatched = !isBlurEvent && isFieldWatched(name);\n\n      if (!isUndefined(inputValue)) {\n        field._f.value = inputValue;\n      }\n\n      const state = updateAndGetDirtyState(name, field._f.value, false);\n\n      if (isBlurEvent && !get(formStateRef.current.touchedFields, name)) {\n        set(formStateRef.current.touchedFields, name, true);\n        readFormStateRef.current.touchedFields && (state.touchedFields = formStateRef.current.touchedFields);\n      }\n\n      let shouldRender = !isEmptyObject(state) || isWatched;\n\n      if (shouldSkipValidation) {\n        !isBlurEvent && watchSubjectRef.current.next({\n          name,\n          type,\n          value: inputValue\n        });\n        return shouldRender && formStateSubjectRef.current.next(isWatched ? {} : state);\n      }\n\n      formStateSubjectRef.current.next({\n        isValidating: true\n      });\n\n      if (resolverRef.current) {\n        const {\n          errors\n        } = await resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef), contextRef.current, {\n          criteriaMode,\n          fields: getFields([name], fieldsRef.current),\n          names: [name]\n        });\n        const previousFormIsValid = formStateRef.current.isValid;\n        error = get(errors, name);\n\n        if (isCheckBoxInput(target) && !error) {\n          const parentNodeName = getNodeParentName(name);\n          const currentError = get(errors, parentNodeName, {});\n          currentError.type && currentError.message && (error = currentError);\n\n          if (currentError || get(formStateRef.current.errors, parentNodeName)) {\n            name = parentNodeName;\n          }\n        }\n\n        isValid = isEmptyObject(errors);\n        previousFormIsValid !== isValid && (shouldRender = true);\n      } else {\n        error = (await validateField(field, isValidateAllFieldCriteria))[name];\n      }\n\n      !isBlurEvent && watchSubjectRef.current.next({\n        name,\n        type,\n        value: inputValue\n      });\n      shouldRenderBaseOnError(name, error, shouldRender, state, isValid, isWatched);\n    }\n  }, []);\n\n  const getValues = fieldNames => {\n    const values = isMountedRef.current ? getFieldsValues(fieldsRef, defaultValuesRef) : defaultValuesRef.current;\n    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map(name => get(values, name));\n  };\n\n  const updateIsValid = React.useCallback(async function () {\n    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const previousIsValid = formStateRef.current.isValid;\n\n    if (resolver) {\n      const {\n        errors\n      } = await resolverRef.current(Object.assign(Object.assign({}, getFieldsValues(fieldsRef, defaultValuesRef)), values), contextRef.current, {\n        criteriaMode,\n        fields: getFields(fieldsNamesRef.current, fieldsRef.current)\n      });\n      formStateRef.current.isValid = isEmptyObject(errors);\n    } else {\n      getIsValid();\n    }\n\n    previousIsValid !== formStateRef.current.isValid && formStateSubjectRef.current.next({\n      isValid: formStateRef.current.isValid\n    });\n  }, [criteriaMode]);\n\n  const clearErrors = name => {\n    name && (Array.isArray(name) ? name : [name]).forEach(inputName => unset(formStateRef.current.errors, inputName));\n    formStateSubjectRef.current.next({\n      errors: name ? formStateRef.current.errors : {}\n    });\n  };\n\n  const setError = (name, error, options) => {\n    const ref = ((get(fieldsRef.current, name) || {\n      _f: {}\n    })._f || {}).ref;\n    set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), {\n      ref\n    }));\n    formStateSubjectRef.current.next({\n      errors: formStateRef.current.errors,\n      isValid: false\n    });\n    options && options.shouldFocus && ref && ref.focus && ref.focus();\n  };\n\n  const watchInternal = React.useCallback((fieldNames, defaultValue, isGlobal) => {\n    const isArrayNames = Array.isArray(fieldNames);\n    const fieldValues = isMountedRef.current ? getValues() : isUndefined(defaultValue) ? defaultValuesRef.current : isArrayNames ? defaultValue || {} : {\n      [fieldNames]: defaultValue\n    };\n\n    if (isUndefined(fieldNames)) {\n      isGlobal && (isWatchAllRef.current = true);\n      return fieldValues;\n    }\n\n    const result = [];\n\n    for (const fieldName of isArrayNames ? fieldNames : [fieldNames]) {\n      isGlobal && watchFieldsRef.current.add(fieldName);\n      result.push(get(fieldValues, fieldName));\n    }\n\n    return isArrayNames ? result : result[0];\n  }, []);\n\n  const watch = (fieldName, defaultValue) => isFunction(fieldName) ? watchSubjectRef.current.subscribe({\n    next: info => fieldName(watchInternal(undefined, defaultValue), info)\n  }) : watchInternal(fieldName, defaultValue, true);\n\n  const unregister = function (name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (const inputName of name ? Array.isArray(name) ? name : [name] : Object.keys(fieldsNamesRef.current)) {\n      fieldsNamesRef.current.delete(inputName);\n      fieldArrayNamesRef.current.delete(inputName);\n\n      if (get(fieldsRef.current, inputName)) {\n        if (!options.keepIsValid) {\n          unset(fieldsWithValidationRef.current, inputName);\n          unset(validFieldsRef.current, inputName);\n        }\n\n        !options.keepError && unset(formStateRef.current.errors, inputName);\n        !options.keepValue && unset(fieldsRef.current, inputName);\n        !options.keepDirty && unset(formStateRef.current.dirtyFields, inputName);\n        !options.keepTouched && unset(formStateRef.current.touchedFields, inputName);\n        !options.keepDefaultValue && unset(defaultValuesRef.current, inputName);\n        watchSubjectRef.current.next({\n          name: inputName\n        });\n      }\n    }\n\n    formStateSubjectRef.current.next(Object.assign(Object.assign(Object.assign({}, formStateRef.current), !options.keepDirty ? {} : {\n      isDirty: getFormIsDirty()\n    }), resolverRef.current ? {} : {\n      isValid: getIsValid()\n    }));\n\n    if (!options.keepIsValid) {\n      updateIsValid();\n    }\n  };\n\n  const registerFieldRef = (name, ref, options) => {\n    let field = get(fieldsRef.current, name);\n\n    if (field) {\n      const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n\n      if ((isRadioOrCheckbox ? Array.isArray(field._f.refs) && compact(field._f.refs).find(option => ref.value === option.value && option === ref) : ref === field._f.ref) || !field || isWeb && isHTMLElement(field._f.ref) && !isHTMLElement(ref)) {\n        return;\n      }\n\n      field = {\n        _f: isRadioOrCheckbox ? Object.assign(Object.assign({}, field._f), {\n          refs: [...compact(field._f.refs || []).filter(ref => isHTMLElement(ref) && document.contains(ref)), ref],\n          ref: {\n            type: ref.type,\n            name\n          }\n        }) : Object.assign(Object.assign({}, field._f), {\n          ref\n        })\n      };\n      set(fieldsRef.current, name, field);\n      const defaultValue = updateValidAndValue(name, options, true);\n\n      if (isRadioOrCheckbox && Array.isArray(defaultValue) ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue) : isUndefined(get(fieldsRef.current, name)._f.value)) {\n        get(fieldsRef.current, name)._f.value = getFieldValue(get(fieldsRef.current, name));\n      }\n    }\n  };\n\n  const register = React.useCallback((name, options) => {\n    const isInitialRegister = !get(fieldsRef.current, name);\n    set(fieldsRef.current, name, {\n      _f: Object.assign(Object.assign(Object.assign({}, isInitialRegister ? {\n        ref: {\n          name\n        }\n      } : Object.assign({\n        ref: (get(fieldsRef.current, name)._f || {}).ref\n      }, get(fieldsRef.current, name)._f)), {\n        name\n      }), options)\n    });\n    options && set(fieldsWithValidationRef.current, name, true);\n    fieldsNamesRef.current.add(name);\n    isInitialRegister && updateValidAndValue(name, options);\n    return isWindowUndefined ? {\n      name: name\n    } : {\n      name,\n      onChange: handleChange,\n      onBlur: handleChange,\n      ref: ref => ref && registerFieldRef(name, ref, options)\n    };\n  }, [defaultValuesRef.current]);\n  const handleSubmit = React.useCallback((onValid, onInvalid) => async e => {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n      e.persist();\n    }\n\n    let fieldValues = Object.assign(Object.assign({}, defaultValuesRef.current), getFieldsValues(fieldsRef, defaultValuesRef));\n    formStateSubjectRef.current.next({\n      isSubmitting: true\n    });\n\n    try {\n      if (resolverRef.current) {\n        const {\n          errors,\n          values\n        } = await resolverRef.current(fieldValues, contextRef.current, {\n          criteriaMode,\n          fields: getFields(fieldsNamesRef.current, fieldsRef.current)\n        });\n        formStateRef.current.errors = errors;\n        fieldValues = values;\n      } else {\n        await validateForm(fieldsRef.current);\n      }\n\n      if (isEmptyObject(formStateRef.current.errors) && Object.keys(formStateRef.current.errors).every(name => get(fieldValues, name))) {\n        formStateSubjectRef.current.next({\n          errors: {},\n          isSubmitting: true\n        });\n        await onValid(fieldValues, e);\n      } else {\n        onInvalid && (await onInvalid(formStateRef.current.errors, e));\n        shouldFocusError && focusFieldBy(fieldsRef.current, key => get(formStateRef.current.errors, key), fieldsNamesRef.current);\n      }\n    } finally {\n      formStateRef.current.isSubmitted = true;\n      formStateSubjectRef.current.next({\n        isSubmitted: true,\n        isSubmitting: false,\n        isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n        submitCount: formStateRef.current.submitCount + 1,\n        errors: formStateRef.current.errors\n      });\n    }\n  }, [shouldFocusError, isValidateAllFieldCriteria, criteriaMode]);\n  const resetFromState = React.useCallback(_ref12 => {\n    let {\n      keepErrors,\n      keepDirty,\n      keepIsSubmitted,\n      keepTouched,\n      keepIsValid,\n      keepSubmitCount\n    } = _ref12;\n\n    if (!keepIsValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n    formStateSubjectRef.current.next({\n      submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\n      isDirty: keepDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: keepIsValid ? formStateRef.current.isValid : !validationMode.isOnSubmit,\n      dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\n      touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\n      errors: keepErrors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false\n    });\n  }, []);\n\n  const reset = function (values) {\n    let keepStateOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const updatedValues = values || defaultValuesRef.current;\n\n    if (isWeb && !keepStateOptions.keepValues) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field && field._f) {\n          const inputRef = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n\n    !keepStateOptions.keepDefaultValues && (defaultValuesRef.current = Object.assign({}, updatedValues));\n\n    if (!keepStateOptions.keepValues) {\n      fieldsRef.current = {};\n      controllerSubjectRef.current.next({\n        values: Object.assign({}, updatedValues)\n      });\n      watchSubjectRef.current.next({\n        value: Object.assign({}, updatedValues)\n      });\n      fieldArraySubjectRef.current.next({\n        fields: Object.assign({}, updatedValues),\n        isReset: true\n      });\n    }\n\n    resetFromState(keepStateOptions);\n  };\n\n  React.useEffect(() => {\n    isMountedRef.current = true;\n    const formStateSubscription = formStateSubjectRef.current.subscribe({\n      next() {\n        let formState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\n          formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), formState);\n          setFormState(formStateRef.current);\n        }\n      }\n\n    });\n    const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\n      next(state) {\n        if (state.fields && state.name && readFormStateRef.current.isValid) {\n          const values = getFieldsValues(fieldsRef);\n          set(values, state.name, state.fields);\n          updateIsValid(values);\n        }\n      }\n\n    });\n    resolverRef.current && readFormStateRef.current.isValid && updateIsValid();\n    return () => {\n      watchSubjectRef.current.unsubscribe();\n      formStateSubscription.unsubscribe();\n      useFieldArraySubscription.unsubscribe();\n    };\n  }, []);\n  return {\n    control: React.useMemo(() => ({\n      register,\n      isWatchAllRef,\n      watchFieldsRef,\n      getFormIsDirty,\n      formStateSubjectRef,\n      fieldArraySubjectRef,\n      controllerSubjectRef,\n      watchSubjectRef,\n      watchInternal,\n      fieldsRef,\n      validFieldsRef,\n      fieldsWithValidationRef,\n      fieldArrayNamesRef,\n      readFormStateRef,\n      formStateRef,\n      defaultValuesRef,\n      fieldArrayDefaultValuesRef\n    }), []),\n    formState: getProxyFormState(isProxyEnabled, formState, readFormStateRef),\n    trigger,\n    register,\n    handleSubmit,\n    watch: React.useCallback(watch, []),\n    setValue: React.useCallback(setValue, [setInternalValues]),\n    getValues: React.useCallback(getValues, []),\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    unregister: React.useCallback(unregister, []),\n    setError: React.useCallback(setError, [])\n  };\n}\n\nfunction useWatch(props) {\n  const {\n    control,\n    name,\n    defaultValue\n  } = props || {};\n  const methods = useFormContext();\n  const nameRef = React.useRef(name);\n  nameRef.current = name;\n  const {\n    watchInternal,\n    watchSubjectRef\n  } = control || methods.control;\n  const [value, updateValue] = React.useState(isUndefined(defaultValue) ? watchInternal(name) : defaultValue);\n  React.useEffect(() => {\n    watchInternal(name);\n    const watchSubscription = watchSubjectRef.current.subscribe({\n      next: _ref13 => {\n        let {\n          name: inputName,\n          value\n        } = _ref13;\n        return (!nameRef.current || !inputName || (Array.isArray(nameRef.current) ? nameRef.current : [nameRef.current]).some(fieldName => inputName && fieldName && inputName.startsWith(fieldName))) && updateValue(isString(inputName) && nameRef.current === inputName && !isUndefined(value) ? value : watchInternal(nameRef.current, defaultValue));\n      }\n    });\n    return () => watchSubscription.unsubscribe();\n  }, []);\n  return value;\n}\n\nexport { Controller, FormProvider, appendErrors, get, set, useController, useFieldArray, useForm, useFormContext, useFormState, useWatch };","map":{"version":3,"mappings":"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","names":["element","type","value","isObjectType","isNullOrUndefined","Array","isArray","Date","event","isObject","target","isCheckBoxInput","checked","name","substring","search","names","some","current","getNodeParentName","filter","Boolean","val","undefined","obj","path","defaultValue","result","compact","split","reduce","key","isUndefined","EVENTS","BLUR","CHANGE","VALIDATION_MODE","onBlur","onChange","onSubmit","onTouched","all","SELECT","UNDEFINED","INPUT_VALIDATION_RULES","max","min","maxLength","minLength","pattern","required","validate","source","copy","FormContext","React","createContext","displayName","useFormContext","useContext","FormProvider","props","Provider","omit","children","isProxyEnabled","formState","readFormStateRef","localReadFormStateRef","isRoot","Proxy","get","prop","Object","keys","length","isEmptyObject","find","window","HTMLElement","document","isWeb","useFormState","methods","formStateRef","formStateSubjectRef","control","updateFormState","useState","readFormState","useRef","isDirty","dirtyFields","touchedFields","isValidating","isValid","errors","useEffect","formStateSubscription","subscribe","next","shouldRenderFormState","unsubscribe","getProxyFormState","useController","rules","defaultValuesRef","register","fieldsRef","fieldArrayNamesRef","controllerSubjectRef","ref","setInputStateValue","_f","isNameInFieldArray","controllerSubscription","data","values","field","getControllerValue","fieldState","defineProperties","invalid","isTouched","error","Controller","render","validateAllFieldCriteria","message","types","test","input","replace","set","object","index","tempPath","isKey","stringToPath","lastIndex","newValue","objValue","isNaN","focusFieldBy","fields","callback","fieldsNames","focus","refs","getFieldsValues","output","disabled","every","d","performance","now","c","r","Math","random","toString","keyName","map","generateId","deepEqual","object1","object2","isErrorObject","isPrimitive","isValidElement","keys1","keys2","val1","val2","deepMerge","targetValue","sourceValue","setDirtyFields","defaultValues","parentNode","parentName","slice","append","fill","insert","from","to","splice","prepend","removeAtIndexes","indexes","i","temp","sort","a","b","indexA","indexB","baseGet","updatePath","unset","childObject","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","isBoolean","useFieldArray","focusNameRef","isWatchAllRef","watchFieldsRef","getFormIsDirty","watchSubjectRef","fieldArraySubjectRef","validFieldsRef","fieldsWithValidationRef","fieldArrayDefaultValuesRef","setFields","mapIds","getFieldArrayParentName","add","omitKey","getCurrentFieldsValues","getFocusDetail","options","focusIndex","focusName","shouldFocus","resetFields","forEach","currentIndex","setFieldsAndNotify","fieldsValues","cleanup","updateDirtyFieldsWithDefaultValues","updatedFieldArrayValues","setFieldArrayDirtyFields","batchStateUpdate","method","args","shouldSet","argA","argB","registerFieldArray","appendValueItem","valueIndex","entries","inputName","appendValue","appendAt","fillEmptyArray","prependValue","prependAt","remove","removeArrayAt","insertValue","insertAt","swap","fieldValues","swapArrayAt","move","moveArrayAt","watchField","startsWith","fieldArraySubscription","inputFieldArrayName","isReset","useCallback","getFields","fieldsRefs","currentFields","defaultResult","validResult","option","attributes","valueAsNumber","valueAsDate","setValueAs","NaN","selected","defaultReturn","previous","getFieldValue","isFileInput","files","isRadioInput","getRadioValue","isMultipleSelect","getMultipleSelectValue","isCheckBox","getCheckboxValue","getFieldValueAs","isOnBlur","isOnChange","isOnTouch","isReValidateOnBlur","isReValidateOnChange","isBlurEvent","isSubmitted","isOnAll","isString","RegExp","getValidateError","isMessage","validationData","isRegex","inputValue","isRadio","isRadioOrCheckbox","isEmpty","appendErrorsCurry","appendErrors","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","getValueAndMessage","exceedMin","maxOutput","minOutput","valueNumber","parseFloat","valueDate","maxLengthOutput","minLengthOutput","patternValue","validateRef","isFunction","validateError","validationResult","validateFunction","validateResult","mode","isOnSubmit","Subscription","constructor","tearDown","tearDowns","push","teardown","Subscriber","observer","subscription","closed","Subject","observers","subscriber","isWindowUndefined","useForm","reValidateMode","resolver","context","shouldFocusError","criteriaMode","fieldsNamesRef","Set","isMountedRef","contextRef","resolverRef","validationMode","getValidationModes","isValidateAllFieldCriteria","setFormState","submitCount","isSubmitting","isSubmitSuccessful","getIsValid","shouldRenderBaseOnError","shouldRender","state","isWatched","previousError","shouldReRender","updatedFormState","setFieldValue","rawValue","shouldRegister","isHTMLElement","radioRef","selectRef","includes","checkboxRef","shouldDirty","updateAndGetDirtyState","shouldValidate","trigger","formValues","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","validateField","executeSchemaOrResolverValidation","currentNames","validateForm","fieldError","Promise","setInternalValues","inputKey","fieldName","isFieldWatched","has","match","updateValidAndValue","isWithinRefCallback","useFormDefaultValue","then","setValue","isFieldArray","handleChange","inputType","shouldSkipValidation","skipValidation","previousFormIsValid","parentNodeName","currentError","getValues","fieldNames","updateIsValid","previousIsValid","clearErrors","setError","watchInternal","isGlobal","isArrayNames","watch","info","unregister","delete","keepIsValid","keepError","keepValue","keepDirty","keepTouched","keepDefaultValue","registerFieldRef","isRadioOrCheckboxFunction","contains","isInitialRegister","handleSubmit","onValid","onInvalid","e","preventDefault","persist","resetFromState","keepErrors","keepIsSubmitted","keepSubmitCount","reset","keepStateOptions","updatedValues","keepValues","inputRef","closest","keepDefaultValues","useFieldArraySubscription","useMemo","useWatch","nameRef","updateValue","watchSubscription"],"sources":["../src/utils/isCheckBoxInput.ts","../src/utils/isNullOrUndefined.ts","../src/utils/isObject.ts","../src/logic/getControllerValue.ts","../src/logic/getNodeParentName.ts","../src/logic/isNameInFieldArray.ts","../src/utils/compact.ts","../src/utils/isUndefined.ts","../src/utils/get.ts","../src/constants.ts","../src/utils/omit.ts","../src/useFormContext.tsx","../src/logic/getProxyFormState.ts","../src/utils/isEmptyObject.ts","../src/logic/shouldRenderFormState.ts","../src/utils/isWeb.ts","../src/utils/isProxyEnabled.ts","../src/useFormState.ts","../src/useController.ts","../src/controller.tsx","../src/logic/appendErrors.ts","../src/utils/isKey.ts","../src/utils/stringToPath.ts","../src/utils/set.ts","../src/logic/focusFieldBy.ts","../src/logic/getFieldsValues.ts","../src/logic/generateId.ts","../src/logic/mapId.ts","../src/utils/isPrimitive.ts","../src/utils/deepEqual.ts","../src/utils/deepMerge.ts","../src/logic/setFieldArrayDirtyFields.ts","../src/utils/append.ts","../src/utils/fillEmptyArray.ts","../src/utils/insert.ts","../src/utils/move.ts","../src/utils/prepend.ts","../src/utils/remove.ts","../src/utils/swap.ts","../src/utils/isBoolean.ts","../src/utils/unset.ts","../src/useFieldArray.ts","../src/logic/getFields.ts","../src/utils/isFileInput.ts","../src/utils/isMultipleSelect.ts","../src/utils/isRadioInput.ts","../src/logic/getCheckboxValue.ts","../src/logic/getFieldValueAs.ts","../src/logic/getMultipleSelectValue.ts","../src/logic/getRadioValue.ts","../src/logic/getFieldValue.ts","../src/logic/skipValidation.ts","../src/utils/isFunction.ts","../src/utils/isString.ts","../src/utils/isMessage.ts","../src/utils/isRegex.ts","../src/logic/getValidateError.ts","../src/logic/getValueAndMessage.ts","../src/logic/validateField.ts","../src/utils/getValidationModes.ts","../src/utils/isHTMLElement.ts","../src/utils/isRadioOrCheckbox.ts","../src/utils/Subject.ts","../src/useForm.ts","../src/useWatch.ts"],"sourcesContent":["import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n","export default (value: unknown): value is null | undefined => value == null;\n","import isNullOrUndefined from './isNullOrUndefined';\n\nexport const isObjectType = (value: unknown) => typeof value === 'object';\n\nexport default <T extends object>(value: unknown): value is T =>\n  !isNullOrUndefined(value) &&\n  !Array.isArray(value) &&\n  isObjectType(value) &&\n  !(value instanceof Date);\n","import isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isObject from '../utils/isObject';\n\ntype Event = { target: any };\n\nexport default (event: unknown) =>\n  isObject(event) && (event as Event).target\n    ? isCheckBoxInput((event as Event).target)\n      ? (event as Event).target.checked\n      : (event as Event).target.value\n    : event;\n","export default (name: string) => name.substring(0, name.search(/.\\d/)) || name;\n","import { InternalFieldName } from '../types';\n\nimport getNodeParentName from './getNodeParentName';\n\nexport default (names: Set<InternalFieldName>, name: InternalFieldName) =>\n  [...names].some((current) => getNodeParentName(name) === current);\n","export default (value: any[]) => value.filter(Boolean);\n","export default (val: unknown): val is undefined => val === undefined;\n","import compact from './compact';\nimport isNullOrUndefined from './isNullOrUndefined';\nimport isUndefined from './isUndefined';\n\nexport default (obj: any = {}, path: string, defaultValue?: unknown) => {\n  const result = compact(path.split(/[,[\\].]+?/)).reduce(\n    (result, key) => (isNullOrUndefined(result) ? result : result[key]),\n    obj,\n  );\n\n  return isUndefined(result) || result === obj\n    ? isUndefined(obj[path])\n      ? defaultValue\n      : obj[path]\n    : result;\n};\n","import { ValidationMode } from './types';\n\nexport const EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n};\n\nexport const VALIDATION_MODE: ValidationMode = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all',\n};\n\nexport const SELECT = 'select';\n\nexport const UNDEFINED = 'undefined';\n\nexport const INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate',\n};\n","export default <Key extends string, T extends Record<Key, any>>(\n  source: T,\n  key: Key,\n): Omit<T, Key> => {\n  const copy = { ...source };\n  delete copy[key];\n\n  return copy;\n};\n","import * as React from 'react';\n\nimport omit from './utils/omit';\nimport { FieldValues, FormProviderProps, UseFormReturn } from './types';\n\nconst FormContext = React.createContext<UseFormReturn | null>(null);\n\nFormContext.displayName = 'RHFContext';\n\nexport const useFormContext = <\n  TFieldValues extends FieldValues\n>(): UseFormReturn<TFieldValues> =>\n  (React.useContext(FormContext) as unknown) as UseFormReturn<TFieldValues>;\n\nexport const FormProvider = <TFieldValues extends FieldValues>(\n  props: FormProviderProps<TFieldValues>,\n) => (\n  <FormContext.Provider\n    value={(omit(props, 'children') as unknown) as UseFormReturn}\n  >\n    {props.children}\n  </FormContext.Provider>\n);\n","import * as React from 'react';\n\nimport { VALIDATION_MODE } from '../constants';\nimport { FormState, FormStateProxy, ReadFormState } from '../types';\n\nexport default <TFieldValues>(\n  isProxyEnabled: boolean,\n  formState: FormState<TFieldValues>,\n  readFormStateRef: React.MutableRefObject<ReadFormState>,\n  localReadFormStateRef?: React.MutableRefObject<ReadFormState>,\n  isRoot = true,\n) =>\n  isProxyEnabled\n    ? new Proxy(formState, {\n        get: (obj, prop: keyof FormStateProxy) => {\n          if (prop in obj) {\n            if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\n              readFormStateRef.current[prop] = isRoot\n                ? VALIDATION_MODE.all\n                : true;\n            }\n            localReadFormStateRef &&\n              (localReadFormStateRef.current[prop] = true);\n            return obj[prop];\n          }\n\n          return undefined;\n        },\n      })\n    : formState;\n","import { EmptyObject } from '../types';\n\nimport isObject from './isObject';\n\nexport default (value: unknown): value is EmptyObject =>\n  isObject(value) && !Object.keys(value).length;\n","import { VALIDATION_MODE } from '../constants';\nimport { ReadFormState } from '../types';\nimport isEmptyObject from '../utils/isEmptyObject';\n\nexport default <T, K extends ReadFormState>(\n  formState: T,\n  readFormStateRef: K,\n  isRoot?: boolean,\n) =>\n  isEmptyObject(formState) ||\n  Object.keys(formState).length >= Object.keys(readFormStateRef).length ||\n  Object.keys(formState).find(\n    (key) =>\n      readFormStateRef[key as keyof ReadFormState] ===\n      (isRoot ? VALIDATION_MODE.all : true),\n  );\n","import { UNDEFINED } from '../constants';\n\nexport default typeof window !== UNDEFINED &&\n  typeof window.HTMLElement !== UNDEFINED &&\n  typeof document !== UNDEFINED;\n","import { UNDEFINED } from '../constants';\n\nimport isWeb from './isWeb';\n\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nexport default isProxyEnabled;\n","import * as React from 'react';\n\nimport getProxyFormState from './logic/getProxyFormState';\nimport shouldRenderFormState from './logic/shouldRenderFormState';\nimport isProxyEnabled from './utils/isProxyEnabled';\nimport {\n  FieldValues,\n  FormState,\n  UseFormStateProps,\n  UseFormStateReturn,\n} from './types';\nimport { useFormContext } from './useFormContext';\n\nfunction useFormState<TFieldValues extends FieldValues = FieldValues>(\n  props?: UseFormStateProps<TFieldValues>,\n): UseFormStateReturn<TFieldValues> {\n  const methods = useFormContext();\n  const { formStateRef, formStateSubjectRef, readFormStateRef } =\n    (props && props.control) || methods.control;\n\n  const [formState, updateFormState] = React.useState(formStateRef.current);\n  const readFormState = React.useRef({\n    isDirty: false,\n    dirtyFields: false,\n    touchedFields: false,\n    isValidating: false,\n    isValid: false,\n    errors: false,\n  });\n\n  React.useEffect(() => {\n    const formStateSubscription = formStateSubjectRef.current.subscribe({\n      next: (formState) => {\n        shouldRenderFormState(formState, readFormState.current) &&\n          updateFormState({\n            ...formStateRef.current,\n            ...formState,\n          });\n      },\n    });\n\n    return () => formStateSubscription.unsubscribe();\n  }, []);\n\n  return getProxyFormState<TFieldValues>(\n    isProxyEnabled,\n    formState as FormState<TFieldValues>,\n    readFormStateRef,\n    readFormState,\n    false,\n  );\n}\n\nexport { useFormState };\n","import * as React from 'react';\n\nimport getControllerValue from './logic/getControllerValue';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport get from './utils/get';\nimport isUndefined from './utils/isUndefined';\nimport { EVENTS } from './constants';\nimport {\n  FieldPath,\n  FieldValues,\n  InternalFieldName,\n  UseControllerProps,\n  UseControllerReturn,\n} from './types';\nimport { useFormContext } from './useFormContext';\nimport { useFormState } from './useFormState';\n\nexport function useController<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>({\n  name,\n  rules,\n  defaultValue,\n  control,\n}: UseControllerProps<TFieldValues, TName>): UseControllerReturn<\n  TFieldValues,\n  TName\n> {\n  const methods = useFormContext<TFieldValues>();\n  const {\n    defaultValuesRef,\n    register,\n    fieldsRef,\n    fieldArrayNamesRef,\n    controllerSubjectRef,\n  } = control || methods.control;\n\n  const { onChange, onBlur, ref } = register(name, rules);\n  const [value, setInputStateValue] = React.useState(\n    isUndefined(get(fieldsRef.current, name)._f.value) ||\n      isNameInFieldArray(fieldArrayNamesRef.current, name)\n      ? isUndefined(defaultValue)\n        ? get(defaultValuesRef.current, name)\n        : defaultValue\n      : get(fieldsRef.current, name)._f.value,\n  );\n  const formState = useFormState({\n    control: control || methods.control,\n  });\n  get(fieldsRef.current, name)._f.value = value;\n\n  React.useEffect(() => {\n    const controllerSubscription = controllerSubjectRef.current.subscribe({\n      next: (data) =>\n        (!data.name || name === data.name) &&\n        setInputStateValue(get(data.values, name)),\n    });\n\n    (ref as (instance: any) => void)({\n      target: value,\n    });\n\n    return () => controllerSubscription.unsubscribe();\n  }, [name]);\n\n  return {\n    field: {\n      onChange: (event: any) => {\n        const value = getControllerValue(event);\n        setInputStateValue(value);\n\n        onChange({\n          target: {\n            value,\n            name: name as InternalFieldName,\n          },\n          type: EVENTS.CHANGE,\n        });\n      },\n      onBlur: () => {\n        onBlur({\n          target: {\n            name: name as InternalFieldName,\n          },\n          type: EVENTS.BLUR,\n        });\n      },\n      name,\n      value,\n      ref,\n    },\n    formState,\n    fieldState: Object.defineProperties(\n      {},\n      {\n        invalid: {\n          get() {\n            return !!get(formState.errors, name);\n          },\n        },\n        isDirty: {\n          get() {\n            return !!get(formState.dirtyFields, name);\n          },\n        },\n        isTouched: {\n          get() {\n            return !!get(formState.touchedFields, name);\n          },\n        },\n        error: {\n          get() {\n            return get(formState.errors, name);\n          },\n        },\n      },\n    ),\n  };\n}\n","import { ControllerProps, FieldPath, FieldValues } from './types';\nimport { useController } from './useController';\n\nconst Controller = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>(\n  props: ControllerProps<TFieldValues, TName>,\n) => props.render(useController<TFieldValues, TName>(props));\n\nexport { Controller };\n","import {\n  InternalFieldErrors,\n  InternalFieldName,\n  ValidateResult,\n} from '../types';\n\nexport default (\n  name: InternalFieldName,\n  validateAllFieldCriteria: boolean,\n  errors: InternalFieldErrors,\n  type: string,\n  message: ValidateResult,\n) =>\n  validateAllFieldCriteria\n    ? {\n        ...errors[name],\n        types: {\n          ...(errors[name] && errors[name]!.types ? errors[name]!.types : {}),\n          [type]: message || true,\n        },\n      }\n    : {};\n","export default (value: string) => /^\\w*$/.test(value);\n","import compact from './compact';\n\nexport default (input: string): string[] =>\n  compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n","import { FieldValues } from '../types';\n\nimport isKey from './isKey';\nimport isObject from './isObject';\nimport stringToPath from './stringToPath';\n\nexport default function set(\n  object: FieldValues,\n  path: string,\n  value?: unknown,\n) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue =\n        isObject(objValue) || Array.isArray(objValue)\n          ? objValue\n          : !isNaN(+tempPath[index + 1])\n          ? []\n          : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\n","import { FieldRefs, InternalFieldName } from '../types';\nimport { get } from '../utils';\nimport isObject from '../utils/isObject';\nimport isUndefined from '../utils/isUndefined';\nimport omit from '../utils/omit';\n\nconst focusFieldBy = (\n  fields: FieldRefs,\n  callback: (name: string) => boolean,\n  fieldsNames?: Set<InternalFieldName>,\n) => {\n  for (const key of fieldsNames || Object.keys(fields)) {\n    const field = get(fields, key);\n\n    if (field) {\n      const _f = field._f;\n      const current = omit(field, '_f');\n\n      if (_f && callback(_f.name)) {\n        if (_f.ref.focus && isUndefined(_f.ref.focus())) {\n          break;\n        } else if (_f.refs) {\n          _f.refs[0].focus();\n          break;\n        }\n      } else if (isObject(current)) {\n        focusFieldBy(current, callback);\n      }\n    }\n  }\n};\n\nexport default focusFieldBy;\n","import * as React from 'react';\n\nimport { FieldRefs, FieldValues } from '../types';\nimport omit from '../utils/omit';\nimport set from '../utils/set';\n\nconst getFieldsValues = (\n  fieldsRef: React.MutableRefObject<FieldRefs>,\n  defaultValuesRef: React.MutableRefObject<FieldValues> = { current: {} },\n  output: Record<string, any> = {},\n): any => {\n  for (const name in fieldsRef.current) {\n    const field = fieldsRef.current[name];\n\n    if (field) {\n      const _f = field._f;\n      const current = omit(field, '_f');\n\n      set(\n        output,\n        name,\n        _f\n          ? _f.ref.disabled || (_f.refs && _f.refs.every((ref) => ref.disabled))\n            ? undefined\n            : _f.value\n          : Array.isArray(field)\n          ? []\n          : {},\n      );\n\n      if (current) {\n        getFieldsValues(\n          {\n            current,\n          },\n          defaultValuesRef,\n          output[name],\n        );\n      }\n    }\n  }\n\n  return {\n    ...defaultValuesRef.current,\n    ...output,\n  };\n};\n\nexport default getFieldsValues;\n","import { UNDEFINED } from '../constants';\n\nexport default () => {\n  const d =\n    typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n};\n","import { FieldValues } from '../types';\n\nimport generateId from './generateId';\n\nexport default <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id'\n>(\n  values: Partial<TFieldArrayValues>[] = [],\n  keyName: TKeyName,\n): any =>\n  values.map((value: Partial<TFieldArrayValues>) => ({\n    [keyName]: (value && value[keyName]) || generateId(),\n    ...value,\n  }));\n","import { Primitive } from '../types';\n\nimport isNullOrUndefined from './isNullOrUndefined';\nimport { isObjectType } from './isObject';\n\nexport default (value: unknown): value is Primitive =>\n  isNullOrUndefined(value) || !isObjectType(value);\n","import * as React from 'react';\n\nimport isObject from '../utils/isObject';\n\nimport isPrimitive from './isPrimitive';\n\nexport default function deepEqual(\n  object1: any,\n  object2: any,\n  isErrorObject?: boolean,\n) {\n  if (\n    isPrimitive(object1) ||\n    isPrimitive(object2) ||\n    object1 instanceof Date ||\n    object2 instanceof Date\n  ) {\n    return object1 === object2;\n  }\n\n  if (!React.isValidElement(object1)) {\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (const key of keys1) {\n      const val1 = object1[key];\n\n      if (!(isErrorObject && key === 'ref')) {\n        const val2 = object2[key];\n\n        if (\n          (isObject(val1) || Array.isArray(val1)) &&\n          (isObject(val2) || Array.isArray(val2))\n            ? !deepEqual(val1, val2, isErrorObject)\n            : val1 !== val2\n        ) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n","import isObject from './isObject';\nimport isPrimitive from './isPrimitive';\n\nexport function deepMerge<\n  T extends Record<keyof T, any>,\n  U extends Record<keyof U, any>\n>(target: T, source: U): T & U {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] =\n        (isObject(targetValue) && isObject(sourceValue)) ||\n        (Array.isArray(targetValue) && Array.isArray(sourceValue))\n          ? deepMerge(targetValue, sourceValue)\n          : sourceValue;\n    } catch {}\n  }\n\n  return target;\n}\n","import { get } from '../utils';\nimport deepEqual from '../utils/deepEqual';\nimport { deepMerge } from '../utils/deepMerge';\nimport set from '../utils/set';\n\nfunction setDirtyFields<\n  T extends Record<string, unknown>[],\n  U extends Record<string, unknown>[],\n  K extends Record<string, boolean | []>\n>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n  parentNode?: K,\n  parentName?: keyof K,\n) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setDirtyFields(\n          values[index][key] as T,\n          get(defaultValues[index] || {}, key, []),\n          dirtyFields[index][key] as [],\n          dirtyFields[index],\n          key,\n        );\n      } else {\n        deepEqual(get(defaultValues[index] || {}, key), values[index][key])\n          ? set(dirtyFields[index] || {}, key)\n          : (dirtyFields[index] = {\n              ...dirtyFields[index],\n              [key]: true,\n            });\n      }\n    }\n\n    parentNode &&\n      !dirtyFields.length &&\n      delete parentNode[parentName as keyof K];\n  }\n\n  return dirtyFields;\n}\n\nexport default <T extends U, U extends Record<string, unknown>[]>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n) =>\n  deepMerge(\n    setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)),\n    setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)),\n  );\n","export default function append<T>(data: T[], value: T | T[]): T[] {\n  return [...data, ...(Array.isArray(value) ? value : [value])];\n}\n","export default <T>(value: T | T[]): undefined[] | undefined =>\n  Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n","export default function insert<T>(data: T[], index: number): (T | undefined)[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value: T | T[],\n): T[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value?: T | T[],\n): (T | undefined)[] {\n  return [\n    ...data.slice(0, index),\n    ...(Array.isArray(value) ? value : [value]),\n    ...data.slice(index),\n  ];\n}\n","import isUndefined from './isUndefined';\n\nexport default <T>(\n  data: (T | undefined)[],\n  from: number,\n  to: number,\n): (T | undefined)[] => {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n","export default function prepend<T>(data: T[], value: T | T[]): T[] {\n  return [...(Array.isArray(value) ? value : [value]), ...data];\n}\n","import compact from './compact';\nimport isUndefined from './isUndefined';\n\nfunction removeAtIndexes<T>(data: T[], indexes: number[]): T[] {\n  let i = 0;\n  const temp = [...data];\n\n  for (const index of indexes) {\n    temp.splice(index - i, 1);\n    i++;\n  }\n\n  return compact(temp).length ? temp : [];\n}\n\nexport default <T>(data: T[], index?: number | number[]): T[] =>\n  isUndefined(index)\n    ? []\n    : removeAtIndexes(\n        data,\n        (Array.isArray(index) ? index : [index]).sort((a, b) => a - b),\n      );\n","export default <T>(data: T[], indexA: number, indexB: number): void => {\n  data[indexA] = [data[indexB], (data[indexB] = data[indexA])][0];\n};\n","export default (value: unknown): value is boolean => typeof value === 'boolean';\n","import isBoolean from './isBoolean';\nimport isEmptyObject from './isEmptyObject';\nimport isKey from './isKey';\nimport isObject from './isObject';\nimport isUndefined from './isUndefined';\nimport stringToPath from './stringToPath';\n\nfunction baseGet(object: any, updatePath: (string | number)[]) {\n  const length = updatePath.slice(0, -1).length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nexport default function unset(object: any, path: string) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject =\n    updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (\n        currentPathsLength === index &&\n        ((isObject(objectRef) && isEmptyObject(objectRef)) ||\n          (Array.isArray(objectRef) &&\n            !objectRef.filter(\n              (data) =>\n                (isObject(data) && !isEmptyObject(data)) || isBoolean(data),\n            ).length))\n      ) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n","import * as React from 'react';\n\nimport focusFieldBy from './logic/focusFieldBy';\nimport getFieldsValues from './logic/getFieldsValues';\nimport getFieldArrayParentName from './logic/getNodeParentName';\nimport mapIds from './logic/mapId';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport appendAt from './utils/append';\nimport compact from './utils/compact';\nimport fillEmptyArray from './utils/fillEmptyArray';\nimport get from './utils/get';\nimport insertAt from './utils/insert';\nimport isPrimitive from './utils/isPrimitive';\nimport isUndefined from './utils/isUndefined';\nimport moveArrayAt from './utils/move';\nimport omit from './utils/omit';\nimport prependAt from './utils/prepend';\nimport removeArrayAt from './utils/remove';\nimport set from './utils/set';\nimport swapArrayAt from './utils/swap';\nimport unset from './utils/unset';\nimport {\n  FieldArray,\n  FieldArrayMethodProps,\n  FieldArrayPath,\n  FieldArrayWithId,\n  FieldErrors,\n  FieldValues,\n  UseFieldArrayProps,\n  UseFieldArrayReturn,\n} from './types';\nimport { useFormContext } from './useFormContext';\n\nexport const useFieldArray = <\n  TFieldValues extends FieldValues = FieldValues,\n  TFieldArrayName extends FieldArrayPath<TFieldValues> = FieldArrayPath<TFieldValues>,\n  TKeyName extends string = 'id'\n>({\n  control,\n  name,\n  keyName = 'id' as TKeyName,\n}: UseFieldArrayProps<\n  TFieldValues,\n  TFieldArrayName,\n  TKeyName\n>): UseFieldArrayReturn<TFieldValues, TFieldArrayName, TKeyName> => {\n  const methods = useFormContext();\n  const focusNameRef = React.useRef('');\n  const {\n    isWatchAllRef,\n    watchFieldsRef,\n    getFormIsDirty,\n    watchSubjectRef,\n    fieldArraySubjectRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    formStateRef,\n    formStateSubjectRef,\n    readFormStateRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n  } = control || methods.control;\n\n  const [fields, setFields] = React.useState<\n    Partial<FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>>[]\n  >(\n    mapIds(\n      get(fieldArrayDefaultValuesRef.current, getFieldArrayParentName(name))\n        ? get(fieldArrayDefaultValuesRef.current, name, [])\n        : get(defaultValuesRef.current, name, []),\n      keyName,\n    ),\n  );\n\n  set(fieldArrayDefaultValuesRef.current, name, [...fields]);\n  fieldArrayNamesRef.current.add(name);\n\n  const omitKey = <\n    T extends Partial<\n      FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>\n    >[]\n  >(\n    fields: T,\n  ) =>\n    fields.map((field) =>\n      omit((field || {}) as Record<TKeyName, any>, keyName),\n    );\n\n  const getCurrentFieldsValues = () => {\n    const values = get(getFieldsValues(fieldsRef, defaultValuesRef), name, []);\n\n    return mapIds<TFieldValues, TKeyName>(\n      get(fieldArrayDefaultValuesRef.current, name, []).map(\n        (item: Partial<TFieldValues>, index: number) => ({\n          ...item,\n          ...values[index],\n        }),\n      ),\n      keyName,\n    );\n  };\n\n  const getFocusDetail = (\n    index: number,\n    options?: FieldArrayMethodProps,\n  ): string =>\n    options\n      ? !isUndefined(options.focusIndex)\n        ? `${name}.${options.focusIndex}`\n        : options.focusName\n        ? options.focusName\n        : !options.shouldFocus\n        ? ''\n        : `${name}.${index}`\n      : `${name}.${index}`;\n\n  const resetFields = <T>(index?: T) =>\n    (Array.isArray(index) ? index : [index]).forEach((currentIndex) =>\n      set(\n        fieldsRef.current,\n        `${name}${isUndefined(currentIndex) ? '' : `.${currentIndex}`}`,\n        isUndefined(currentIndex) ? [] : undefined,\n      ),\n    );\n\n  const setFieldsAndNotify = (\n    fieldsValues: Partial<FieldArray<TFieldValues, TFieldArrayName>>[] = [],\n  ) => setFields(mapIds(fieldsValues, keyName));\n\n  const cleanup = <T>(ref: T) =>\n    !compact(get(ref, name, [])).length && unset(ref, name);\n\n  const updateDirtyFieldsWithDefaultValues = <\n    T extends Partial<\n      FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>\n    >[]\n  >(\n    updatedFieldArrayValues?: T,\n  ) =>\n    updatedFieldArrayValues &&\n    set(\n      formStateRef.current.dirtyFields,\n      name,\n      setFieldArrayDirtyFields(\n        omitKey(updatedFieldArrayValues),\n        get(defaultValuesRef.current, name, []),\n        get(formStateRef.current.dirtyFields, name, []),\n      ),\n    );\n\n  const batchStateUpdate = <T extends Function>(\n    method: T,\n    args: {\n      argA?: unknown;\n      argB?: unknown;\n    },\n    updatedFieldArrayValues: Partial<\n      FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>\n    >[] = [],\n    shouldSet = true,\n  ) => {\n    if (get(fieldsRef.current, name)) {\n      const output = method(get(fieldsRef.current, name), args.argA, args.argB);\n      shouldSet && set(fieldsRef.current, name, output);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      const output = method(\n        get(formStateRef.current.errors, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (\n      readFormStateRef.current.touchedFields &&\n      get(formStateRef.current.touchedFields, name)\n    ) {\n      const output = method(\n        get(formStateRef.current.touchedFields, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.touchedFields, name, output);\n      cleanup(formStateRef.current.touchedFields);\n    }\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      set(\n        formStateRef.current.dirtyFields,\n        name,\n        setFieldArrayDirtyFields(\n          omitKey(updatedFieldArrayValues),\n          get(defaultValuesRef.current, name, []),\n          get(formStateRef.current.dirtyFields, name, []),\n        ),\n      );\n      updateDirtyFieldsWithDefaultValues(updatedFieldArrayValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (readFormStateRef.current.isValid) {\n      set(\n        validFieldsRef.current,\n        name,\n        method(get(validFieldsRef.current, name, []), args.argA),\n      );\n      cleanup(validFieldsRef.current);\n\n      set(\n        fieldsWithValidationRef.current,\n        name,\n        method(get(fieldsWithValidationRef.current, name, []), args.argA),\n      );\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    formStateSubjectRef.current.next({\n      isDirty: getFormIsDirty(name, omitKey(updatedFieldArrayValues)),\n      errors: formStateRef.current.errors as FieldErrors<TFieldValues>,\n      isValid: formStateRef.current.isValid,\n    });\n  };\n\n  const registerFieldArray = <T extends Object[]>(\n    values: T,\n    index = 0,\n    parentName = '',\n  ) =>\n    values.forEach(\n      (appendValueItem, valueIndex) =>\n        !isPrimitive(appendValueItem) &&\n        Object.entries(appendValueItem).forEach(([key, value]) => {\n          const inputName = `${parentName || name}.${\n            parentName ? valueIndex : index + valueIndex\n          }.${key}`;\n\n          Array.isArray(value)\n            ? registerFieldArray(value, valueIndex, inputName)\n            : set(fieldsRef.current, inputName, {\n                _f: {\n                  ref: {\n                    name: inputName,\n                  },\n                  name: inputName,\n                  value,\n                },\n              });\n        }),\n    );\n\n  const append = (\n    value:\n      | Partial<FieldArray<TFieldValues, TFieldArrayName>>\n      | Partial<FieldArray<TFieldValues, TFieldArrayName>>[],\n    options?: FieldArrayMethodProps,\n  ) => {\n    const appendValue = Array.isArray(value) ? value : [value];\n    const updatedFieldArrayValues = appendAt(\n      getCurrentFieldsValues(),\n      appendValue,\n    );\n    const currentIndex = updatedFieldArrayValues.length - appendValue.length;\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(\n      appendAt,\n      {\n        argA: fillEmptyArray(value),\n      },\n      updatedFieldArrayValues as Partial<\n        FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>\n      >[],\n      false,\n    );\n    registerFieldArray(appendValue, currentIndex);\n\n    focusNameRef.current = getFocusDetail(currentIndex, options);\n  };\n\n  const prepend = (\n    value:\n      | Partial<FieldArray<TFieldValues, TFieldArrayName>>\n      | Partial<FieldArray<TFieldValues, TFieldArrayName>>[],\n    options?: FieldArrayMethodProps,\n  ) => {\n    const prependValue = Array.isArray(value) ? value : [value];\n    const updatedFieldArrayValues = prependAt(\n      getCurrentFieldsValues(),\n      prependValue,\n    );\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(\n      prependAt,\n      {\n        argA: fillEmptyArray(value),\n      },\n      updatedFieldArrayValues as Partial<\n        FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>\n      >[],\n    );\n    registerFieldArray(prependValue);\n\n    focusNameRef.current = getFocusDetail(0, options);\n  };\n\n  const remove = (index?: number | number[]) => {\n    const updatedFieldArrayValues: Partial<\n      FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>\n    >[] = removeArrayAt(getCurrentFieldsValues(), index);\n    resetFields(index);\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(\n      removeArrayAt,\n      {\n        argA: index,\n      },\n      updatedFieldArrayValues,\n    );\n  };\n\n  const insert = (\n    index: number,\n    value:\n      | Partial<FieldArray<TFieldValues, TFieldArrayName>>\n      | Partial<FieldArray<TFieldValues, TFieldArrayName>>[],\n    options?: FieldArrayMethodProps,\n  ) => {\n    const insertValue = Array.isArray(value) ? value : [value];\n    const updatedFieldArrayValues = insertAt(\n      getCurrentFieldsValues(),\n      index,\n      insertValue,\n    );\n    setFieldsAndNotify(updatedFieldArrayValues);\n    batchStateUpdate(\n      insertAt,\n      {\n        argA: index,\n        argB: fillEmptyArray(value),\n      },\n      updatedFieldArrayValues as Partial<\n        FieldArrayWithId<TFieldValues, TFieldArrayName, TKeyName>\n      >[],\n    );\n    registerFieldArray(insertValue, index);\n\n    focusNameRef.current = getFocusDetail(index, options);\n  };\n\n  const swap = (indexA: number, indexB: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    batchStateUpdate(\n      swapArrayAt,\n      {\n        argA: indexA,\n        argB: indexB,\n      },\n      fieldValues,\n      false,\n    );\n    setFieldsAndNotify(fieldValues);\n  };\n\n  const move = (from: number, to: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    setFieldsAndNotify(fieldValues);\n    batchStateUpdate(\n      moveArrayAt,\n      {\n        argA: from,\n        argB: to,\n      },\n      fieldValues,\n      false,\n    );\n  };\n\n  React.useEffect(() => {\n    if (isWatchAllRef.current) {\n      formStateSubjectRef.current.next({});\n    } else {\n      for (const watchField of watchFieldsRef.current) {\n        if (name.startsWith(watchField)) {\n          formStateSubjectRef.current.next({});\n          break;\n        }\n      }\n    }\n\n    watchSubjectRef.current.next({\n      name,\n      value: get(getFieldsValues(fieldsRef, defaultValuesRef), name, []),\n    });\n\n    focusNameRef.current &&\n      focusFieldBy(fieldsRef.current, (key: string) =>\n        key.startsWith(focusNameRef.current),\n      );\n\n    focusNameRef.current = '';\n\n    fieldArraySubjectRef.current.next({\n      name,\n      fields: omitKey([...fields]),\n    });\n  }, [fields, name]);\n\n  React.useEffect(() => {\n    const fieldArraySubscription = fieldArraySubjectRef.current.subscribe({\n      next({ name: inputFieldArrayName, fields, isReset }) {\n        if (isReset) {\n          unset(fieldsRef.current, inputFieldArrayName || name);\n\n          inputFieldArrayName\n            ? set(\n                fieldArrayDefaultValuesRef.current,\n                inputFieldArrayName,\n                fields,\n              )\n            : (fieldArrayDefaultValuesRef.current = fields);\n\n          setFieldsAndNotify(get(fieldArrayDefaultValuesRef.current, name));\n        }\n      },\n    });\n    !get(fieldsRef.current, name) && set(fieldsRef.current, name, []);\n\n    return () => {\n      fieldArrayDefaultValuesRef.current = getFieldsValues(fieldsRef);\n      fieldArraySubscription.unsubscribe();\n    };\n  }, []);\n\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend, [name]),\n    append: React.useCallback(append, [name]),\n    remove: React.useCallback(remove, [name]),\n    insert: React.useCallback(insert, [name]),\n    fields: fields as FieldArrayWithId<\n      TFieldValues,\n      TFieldArrayName,\n      TKeyName\n    >[],\n  };\n};\n","import { Field, FieldRefs, InternalFieldName } from '../types';\nimport { get } from '../utils';\nimport isKey from '../utils/isKey';\nimport set from '../utils/set';\n\nexport default function getFields(\n  fieldsNames: Set<InternalFieldName> | InternalFieldName[],\n  fieldsRefs: FieldRefs,\n) {\n  const currentFields: Record<InternalFieldName, Field['_f']> = {};\n\n  for (const name of fieldsNames) {\n    const field = get(fieldsRefs, name) as Field | undefined;\n\n    if (field) {\n      !isKey(name)\n        ? set(currentFields, name, field._f)\n        : (currentFields[name] = field._f);\n    }\n  }\n\n  return currentFields;\n}\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'file';\n","import { SELECT } from '../constants';\nimport { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-multiple`;\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'radio';\n","import isUndefined from '../utils/isUndefined';\n\ntype CheckboxFieldResult = {\n  isValid: boolean;\n  value: string | string[] | boolean | undefined;\n};\n\nconst defaultResult: CheckboxFieldResult = {\n  value: false,\n  isValid: false,\n};\n\nconst validResult = { value: true, isValid: true };\n\nexport default (options?: HTMLInputElement[]): CheckboxFieldResult => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options\n        .filter((option) => option && option.checked && !option.disabled)\n        .map((option) => option.value);\n      return { value: values, isValid: !!values.length };\n    }\n\n    return options[0].checked && !options[0].disabled\n      ? // @ts-expect-error expected to work in the browser\n        options[0].attributes && !isUndefined(options[0].attributes.value)\n        ? isUndefined(options[0].value) || options[0].value === ''\n          ? validResult\n          : { value: options[0].value, isValid: true }\n        : validResult\n      : defaultResult;\n  }\n\n  return defaultResult;\n};\n","import { Field } from '../types';\n\nexport default (\n  value: any,\n  { valueAsNumber, valueAsDate, setValueAs }: Field['_f'],\n) =>\n  valueAsNumber\n    ? value === ''\n      ? NaN\n      : +value\n    : valueAsDate\n    ? new Date(value)\n    : setValueAs\n    ? setValueAs(value)\n    : value;\n","export default (\n  options: HTMLOptionElement[] | HTMLOptionsCollection,\n): string[] =>\n  [...options]\n    .filter(({ selected }): boolean => selected)\n    .map(({ value }): string => value);\n","type RadioFieldResult = {\n  isValid: boolean;\n  value: number | string | null;\n};\n\nconst defaultReturn: RadioFieldResult = {\n  isValid: false,\n  value: null,\n};\n\nexport default (options?: HTMLInputElement[]): RadioFieldResult =>\n  Array.isArray(options)\n    ? options.reduce(\n        (previous, option): RadioFieldResult =>\n          option && option.checked && !option.disabled\n            ? {\n                isValid: true,\n                value: option.value,\n              }\n            : previous,\n        defaultReturn,\n      )\n    : defaultReturn;\n","import { Field } from '../types';\nimport isCheckBox from '../utils/isCheckBoxInput';\nimport isFileInput from '../utils/isFileInput';\nimport isMultipleSelect from '../utils/isMultipleSelect';\nimport isRadioInput from '../utils/isRadioInput';\nimport isUndefined from '../utils/isUndefined';\n\nimport getCheckboxValue from './getCheckboxValue';\nimport getFieldValueAs from './getFieldValueAs';\nimport getMultipleSelectValue from './getMultipleSelectValue';\nimport getRadioValue from './getRadioValue';\n\nexport default function getFieldValue(field?: Field) {\n  if (field && field._f) {\n    const ref = field._f.ref;\n\n    if (ref.disabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field._f.refs).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBox(ref)) {\n      return getCheckboxValue(field._f.refs).value;\n    }\n\n    return getFieldValueAs(\n      isUndefined(ref.value) ? field._f.ref.value : ref.value,\n      field._f,\n    );\n  }\n}\n","export default ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll,\n}: {\n  isOnAll?: boolean;\n  isOnBlur?: boolean;\n  isOnChange?: boolean;\n  isReValidateOnBlur?: boolean;\n  isReValidateOnChange?: boolean;\n  isBlurEvent?: boolean;\n  isSubmitted?: boolean;\n  isOnTouch?: boolean;\n  isTouched?: boolean;\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n  return true;\n};\n","export default (value: unknown): value is Function =>\n  typeof value === 'function';\n","export default (value: unknown): value is string => typeof value === 'string';\n","import * as React from 'react';\n\nimport { Message } from '../types';\nimport isString from '../utils/isString';\n\nexport default (value: unknown): value is Message =>\n  isString(value) || React.isValidElement(value as JSX.Element);\n","export default (value: unknown): value is RegExp => value instanceof RegExp;\n","import { FieldError, Ref, ValidateResult } from '../types';\nimport isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\n\nexport default function getValidateError(\n  result: ValidateResult,\n  ref: Ref,\n  type = 'validate',\n): FieldError | void {\n  if (isMessage(result) || (isBoolean(result) && !result)) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref,\n    };\n  }\n}\n","import { ValidationRule } from '../types';\nimport isObject from '../utils/isObject';\nimport isRegex from '../utils/isRegex';\n\nexport default (validationData?: ValidationRule) =>\n  isObject(validationData) && !isRegex(validationData)\n    ? validationData\n    : {\n        value: validationData,\n        message: '',\n      };\n","import { INPUT_VALIDATION_RULES } from '../constants';\nimport { Field, FieldError, InternalFieldErrors, Message } from '../types';\nimport isBoolean from '../utils/isBoolean';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isFileInput from '../utils/isFileInput';\nimport isFunction from '../utils/isFunction';\nimport isMessage from '../utils/isMessage';\nimport isNullOrUndefined from '../utils/isNullOrUndefined';\nimport isObject from '../utils/isObject';\nimport isRadioInput from '../utils/isRadioInput';\nimport isRegex from '../utils/isRegex';\nimport isString from '../utils/isString';\n\nimport appendErrors from './appendErrors';\nimport getCheckboxValue from './getCheckboxValue';\nimport getRadioValue from './getRadioValue';\nimport getValidateError from './getValidateError';\nimport getValueAndMessage from './getValueAndMessage';\n\nexport default async (\n  {\n    _f: {\n      ref,\n      refs,\n      required,\n      maxLength,\n      minLength,\n      min,\n      max,\n      pattern,\n      validate,\n      name,\n      value: inputValue,\n      valueAsNumber,\n    },\n  }: Field,\n  validateAllFieldCriteria: boolean,\n): Promise<InternalFieldErrors> => {\n  const error: InternalFieldErrors = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty =\n    ((valueAsNumber || isFileInput(ref)) && !ref.value) ||\n    inputValue === '' ||\n    (Array.isArray(inputValue) && !inputValue.length);\n  const appendErrorsCurry = appendErrors.bind(\n    null,\n    name,\n    validateAllFieldCriteria,\n    error,\n  );\n  const getMinMaxMessage = (\n    exceedMax: boolean,\n    maxLengthMessage: Message,\n    minLengthMessage: Message,\n    maxType = INPUT_VALIDATION_RULES.maxLength,\n    minType = INPUT_VALIDATION_RULES.minLength,\n  ) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = {\n      type: exceedMax ? maxType : minType,\n      message,\n      ref,\n      ...appendErrorsCurry(exceedMax ? maxType : minType, message),\n    };\n  };\n\n  if (\n    required &&\n    ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue))) ||\n      (isBoolean(inputValue) && !inputValue) ||\n      (isCheckBox && !getCheckboxValue(refs).isValid) ||\n      (isRadio && !getRadioValue(refs).isValid))\n  ) {\n    const { value, message } = isMessage(required)\n      ? { value: !!required, message: required }\n      : getValueAndMessage(required);\n\n    if (value) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.required,\n        message,\n        ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (\n    (!isNullOrUndefined(min) || !isNullOrUndefined(max)) &&\n    inputValue !== ''\n  ) {\n    let exceedMax;\n    let exceedMin;\n    const maxOutput = getValueAndMessage(max);\n    const minOutput = getValueAndMessage(min);\n\n    if (!isNaN(inputValue)) {\n      const valueNumber =\n        (ref as HTMLInputElement).valueAsNumber || parseFloat(inputValue);\n      if (!isNullOrUndefined(maxOutput.value)) {\n        exceedMax = valueNumber > maxOutput.value;\n      }\n      if (!isNullOrUndefined(minOutput.value)) {\n        exceedMin = valueNumber < minOutput.value;\n      }\n    } else {\n      const valueDate =\n        (ref as HTMLInputElement).valueAsDate || new Date(inputValue);\n      if (isString(maxOutput.value)) {\n        exceedMax = valueDate > new Date(maxOutput.value);\n      }\n      if (isString(minOutput.value)) {\n        exceedMin = valueDate < new Date(minOutput.value);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        !!exceedMax,\n        maxOutput.message,\n        minOutput.message,\n        INPUT_VALIDATION_RULES.max,\n        INPUT_VALIDATION_RULES.min,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {\n    const maxLengthOutput = getValueAndMessage(maxLength);\n    const minLengthOutput = getValueAndMessage(minLength);\n    const exceedMax =\n      !isNullOrUndefined(maxLengthOutput.value) &&\n      inputValue.length > maxLengthOutput.value;\n    const exceedMin =\n      !isNullOrUndefined(minLengthOutput.value) &&\n      inputValue.length < minLengthOutput.value;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        exceedMax,\n        maxLengthOutput.message,\n        minLengthOutput.message,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(inputValue) && pattern && !isEmpty) {\n    const { value: patternValue, message } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !patternValue.test(inputValue)) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.pattern,\n        message,\n        ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(inputValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = {\n          ...validateError,\n          ...appendErrorsCurry(\n            INPUT_VALIDATION_RULES.validate,\n            validateError.message,\n          ),\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {} as FieldError;\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(inputValue);\n        const validateError = getValidateError(\n          validateResult,\n          validateRef,\n          key,\n        );\n\n        if (validateError) {\n          validationResult = {\n            ...validateError,\n            ...appendErrorsCurry(key, validateError.message),\n          };\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = {\n          ref: validateRef,\n          ...validationResult,\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n","import { VALIDATION_MODE } from '../constants';\nimport { Mode } from '../types';\n\nexport default (\n  mode?: Mode,\n): {\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isOnChange: boolean;\n  isOnAll: boolean;\n  isOnTouch: boolean;\n} => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched,\n});\n","export default (value: any): value is HTMLElement =>\n  value instanceof HTMLElement;\n","import { FieldElement } from '../types';\n\nimport isCheckBoxInput from './isCheckBoxInput';\nimport isRadioInput from './isRadioInput';\n\nexport default (ref: FieldElement): ref is HTMLInputElement =>\n  isRadioInput(ref) || isCheckBoxInput(ref);\n","export type Observer<T> = {\n  next: (value: T) => void;\n};\n\ntype TearDown = () => void;\n\nexport type SubjectType<T> = {\n  next: (value: T) => void;\n  subscribe: (\n    value: Observer<T>,\n  ) => {\n    unsubscribe: TearDown;\n  };\n};\n\nexport class Subscription {\n  private tearDowns: TearDown[] = [];\n\n  add(tearDown: TearDown) {\n    this.tearDowns.push(tearDown);\n  }\n\n  unsubscribe() {\n    for (const teardown of this.tearDowns) {\n      teardown();\n    }\n    this.tearDowns = [];\n  }\n}\n\nclass Subscriber<T> implements Observer<T> {\n  closed = false;\n\n  constructor(private observer: Observer<T>, subscription: Subscription) {\n    subscription.add(() => (this.closed = true));\n  }\n\n  next(value: T) {\n    if (!this.closed) {\n      this.observer.next(value);\n    }\n  }\n}\n\nexport default class Subject<T> {\n  observers: Observer<T>[];\n\n  constructor() {\n    this.observers = [];\n  }\n\n  next(value: T) {\n    for (const observer of this.observers) {\n      observer.next(value);\n    }\n  }\n\n  subscribe(observer: Observer<T>) {\n    const subscription = new Subscription();\n    const subscriber = new Subscriber(observer, subscription);\n    this.observers.push(subscriber);\n\n    return subscription;\n  }\n\n  unsubscribe() {\n    this.observers = [];\n  }\n}\n","import * as React from 'react';\n\nimport focusFieldBy from './logic/focusFieldBy';\nimport getFields from './logic/getFields';\nimport getFieldsValues from './logic/getFieldsValues';\nimport getFieldValue from './logic/getFieldValue';\nimport getNodeParentName from './logic/getNodeParentName';\nimport getProxyFormState from './logic/getProxyFormState';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport shouldRenderFormState from './logic/shouldRenderFormState';\nimport skipValidation from './logic/skipValidation';\nimport validateField from './logic/validateField';\nimport compact from './utils/compact';\nimport deepEqual from './utils/deepEqual';\nimport get from './utils/get';\nimport getValidationModes from './utils/getValidationModes';\nimport isCheckBoxInput from './utils/isCheckBoxInput';\nimport isEmptyObject from './utils/isEmptyObject';\nimport isFileInput from './utils/isFileInput';\nimport isFunction from './utils/isFunction';\nimport isHTMLElement from './utils/isHTMLElement';\nimport isMultipleSelect from './utils/isMultipleSelect';\nimport isNullOrUndefined from './utils/isNullOrUndefined';\nimport isProxyEnabled from './utils/isProxyEnabled';\nimport isRadioInput from './utils/isRadioInput';\nimport isRadioOrCheckboxFunction from './utils/isRadioOrCheckbox';\nimport isString from './utils/isString';\nimport isUndefined from './utils/isUndefined';\nimport isWeb from './utils/isWeb';\nimport omit from './utils/omit';\nimport set from './utils/set';\nimport Subject from './utils/Subject';\nimport unset from './utils/unset';\nimport { EVENTS, UNDEFINED, VALIDATION_MODE } from './constants';\nimport {\n  ChangeHandler,\n  DeepPartial,\n  DefaultValues,\n  EventType,\n  Field,\n  FieldArrayDefaultValues,\n  FieldError,\n  FieldName,\n  FieldNamesMarkedBoolean,\n  FieldPath,\n  FieldRefs,\n  FieldValues,\n  FormState,\n  GetFormIsDirty,\n  InternalFieldName,\n  InternalNameSet,\n  KeepStateOptions,\n  Path,\n  PathValue,\n  ReadFormState,\n  Ref,\n  RegisterOptions,\n  SetFieldValue,\n  SetValueConfig,\n  UnpackNestedValue,\n  UseFormClearErrors,\n  UseFormGetValues,\n  UseFormHandleSubmit,\n  UseFormProps,\n  UseFormRegister,\n  UseFormRegisterReturn,\n  UseFormReset,\n  UseFormReturn,\n  UseFormSetError,\n  UseFormSetValue,\n  UseFormTrigger,\n  UseFormUnregister,\n  UseFormWatch,\n  WatchInternal,\n  WatchObserver,\n} from './types';\n\nconst isWindowUndefined = typeof window === UNDEFINED;\n\nexport function useForm<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext extends object = object\n>({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {} as DefaultValues<TFieldValues>,\n  shouldFocusError = true,\n  criteriaMode,\n}: UseFormProps<TFieldValues, TContext> = {}): UseFormReturn<TFieldValues> {\n  const fieldsRef = React.useRef<FieldRefs>({});\n  const fieldsNamesRef = React.useRef<Set<InternalFieldName>>(new Set());\n  const formStateSubjectRef = React.useRef(\n    new Subject<Partial<FormState<TFieldValues>>>(),\n  );\n  const watchSubjectRef = React.useRef(\n    new Subject<{\n      name?: InternalFieldName;\n      type?: EventType;\n      value?: unknown;\n    }>(),\n  );\n  const controllerSubjectRef = React.useRef(\n    new Subject<{\n      name?: InternalFieldName;\n      values: DefaultValues<TFieldValues>;\n    }>(),\n  );\n  const fieldArraySubjectRef = React.useRef(\n    new Subject<{\n      name?: InternalFieldName;\n      fields: any;\n      isReset?: boolean;\n    }>(),\n  );\n  const fieldArrayDefaultValuesRef = React.useRef<FieldArrayDefaultValues>({});\n  const watchFieldsRef = React.useRef<InternalNameSet>(new Set());\n  const isMountedRef = React.useRef(false);\n  const fieldsWithValidationRef = React.useRef<\n    FieldNamesMarkedBoolean<TFieldValues>\n  >({});\n  const validFieldsRef = React.useRef<FieldNamesMarkedBoolean<TFieldValues>>(\n    {},\n  );\n  const defaultValuesRef = React.useRef<DefaultValues<TFieldValues>>(\n    defaultValues,\n  );\n  const isWatchAllRef = React.useRef(false);\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef<InternalNameSet>(new Set());\n  const validationMode = getValidationModes(mode);\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = React.useState<FormState<TFieldValues>>({\n    isDirty: false,\n    isValidating: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touchedFields: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !validationMode.isOnSubmit,\n    errors: {},\n  });\n  const readFormStateRef = React.useRef<ReadFormState>({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touchedFields: !isProxyEnabled,\n    isValidating: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n    errors: !isProxyEnabled,\n  });\n  const formStateRef = React.useRef(formState);\n\n  contextRef.current = context;\n  resolverRef.current = resolver;\n\n  const getIsValid = () =>\n    (formStateRef.current.isValid =\n      deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\n      isEmptyObject(formStateRef.current.errors));\n\n  const shouldRenderBaseOnError = React.useCallback(\n    (\n      name: InternalFieldName,\n      error?: FieldError,\n      shouldRender: boolean | null = false,\n      state: {\n        dirty?: FieldNamesMarkedBoolean<TFieldValues>;\n        isDirty?: boolean;\n        touched?: FieldNamesMarkedBoolean<TFieldValues>;\n      } = {},\n      isValid?: boolean,\n      isWatched?: boolean,\n    ): boolean | void => {\n      const previousError = get(formStateRef.current.errors, name);\n\n      let shouldReRender =\n        shouldRender ||\n        !deepEqual(previousError, error, true) ||\n        (readFormStateRef.current.isValid &&\n          isUndefined(error) &&\n          get(fieldsWithValidationRef.current, name) &&\n          !get(validFieldsRef.current, name));\n\n      if (error) {\n        unset(validFieldsRef.current, name);\n        shouldReRender =\n          shouldReRender ||\n          !previousError ||\n          !deepEqual(previousError, error, true);\n        set(formStateRef.current.errors, name, error);\n      } else {\n        if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n          set(validFieldsRef.current, name, true);\n          shouldReRender = shouldReRender || previousError;\n        }\n\n        unset(formStateRef.current.errors, name);\n      }\n\n      if (\n        (shouldReRender && !isNullOrUndefined(shouldRender)) ||\n        !isEmptyObject(state) ||\n        isWatched\n      ) {\n        const updatedFormState = {\n          ...state,\n          isValid: resolverRef.current ? !!isValid : getIsValid(),\n          errors: formStateRef.current.errors,\n        };\n\n        formStateRef.current = {\n          ...formStateRef.current,\n          ...updatedFormState,\n        };\n\n        formStateSubjectRef.current.next(isWatched ? {} : updatedFormState);\n      }\n\n      formStateSubjectRef.current.next({\n        isValidating: false,\n      });\n    },\n    [],\n  );\n\n  const setFieldValue = React.useCallback(\n    (\n      name: InternalFieldName,\n      rawValue: SetFieldValue<TFieldValues>,\n      options: SetValueConfig = {},\n      shouldRender?: boolean,\n      shouldRegister?: boolean,\n    ) => {\n      shouldRegister && register(name as Path<TFieldValues>);\n      const _f = get(fieldsRef.current, name, {})._f as Field['_f'];\n\n      if (_f) {\n        const value =\n          isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(rawValue)\n            ? ''\n            : rawValue;\n        _f.value = rawValue;\n\n        if (isRadioInput(_f.ref)) {\n          (_f.refs || []).forEach(\n            (radioRef: HTMLInputElement) =>\n              (radioRef.checked = radioRef.value === value),\n          );\n        } else if (isFileInput(_f.ref) && !isString(value)) {\n          _f.ref.files = value as FileList;\n        } else if (isMultipleSelect(_f.ref)) {\n          [..._f.ref.options].forEach(\n            (selectRef) =>\n              (selectRef.selected = (value as string[]).includes(\n                selectRef.value,\n              )),\n          );\n        } else if (isCheckBoxInput(_f.ref) && _f.refs) {\n          _f.refs.length > 1\n            ? _f.refs.forEach(\n                (checkboxRef) =>\n                  (checkboxRef.checked = Array.isArray(value)\n                    ? !!(value as []).find(\n                        (data: string) => data === checkboxRef.value,\n                      )\n                    : value === checkboxRef.value),\n              )\n            : (_f.refs[0].checked = !!value);\n        } else {\n          _f.ref.value = value;\n        }\n\n        if (shouldRender) {\n          const values = getFieldsValues(fieldsRef);\n          set(values, name, rawValue);\n          controllerSubjectRef.current.next({\n            values: {\n              ...defaultValuesRef.current,\n              ...values,\n            } as DefaultValues<TFieldValues>,\n            name,\n          });\n        }\n\n        options.shouldDirty && updateAndGetDirtyState(name, value);\n        options.shouldValidate && trigger(name as Path<TFieldValues>);\n      }\n    },\n    [],\n  );\n\n  const getFormIsDirty: GetFormIsDirty = React.useCallback((name, data) => {\n    if (readFormStateRef.current.isDirty) {\n      const formValues = getFieldsValues(fieldsRef);\n\n      name && data && set(formValues, name, data);\n\n      return !deepEqual(formValues, defaultValuesRef.current);\n    }\n\n    return false;\n  }, []);\n\n  const updateAndGetDirtyState = React.useCallback(\n    (\n      name: InternalFieldName,\n      inputValue: unknown,\n      shouldRender = true,\n    ): Partial<\n      Pick<FormState<TFieldValues>, 'dirtyFields' | 'isDirty' | 'touchedFields'>\n    > => {\n      if (\n        readFormStateRef.current.isDirty ||\n        readFormStateRef.current.dirtyFields\n      ) {\n        const isFieldDirty = !deepEqual(\n          get(defaultValuesRef.current, name),\n          inputValue,\n        );\n        const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n        const previousIsDirty = formStateRef.current.isDirty;\n\n        isFieldDirty\n          ? set(formStateRef.current.dirtyFields, name, true)\n          : unset(formStateRef.current.dirtyFields, name);\n\n        formStateRef.current.isDirty = getFormIsDirty();\n\n        const state = {\n          isDirty: formStateRef.current.isDirty,\n          dirtyFields: formStateRef.current.dirtyFields,\n        };\n\n        const isChanged =\n          (readFormStateRef.current.isDirty &&\n            previousIsDirty !== state.isDirty) ||\n          (readFormStateRef.current.dirtyFields &&\n            isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\n\n        isChanged && shouldRender && formStateSubjectRef.current.next(state);\n\n        return isChanged ? state : {};\n      }\n\n      return {};\n    },\n    [],\n  );\n\n  const executeValidation = React.useCallback(\n    async (\n      name: InternalFieldName,\n      skipReRender?: boolean | null,\n    ): Promise<boolean> => {\n      const error = (\n        await validateField(\n          get(fieldsRef.current, name) as Field,\n          isValidateAllFieldCriteria,\n        )\n      )[name];\n\n      shouldRenderBaseOnError(name, error, skipReRender);\n\n      return isUndefined(error);\n    },\n    [isValidateAllFieldCriteria],\n  );\n\n  const executeSchemaOrResolverValidation = React.useCallback(\n    async (\n      names: InternalFieldName[],\n      currentNames: FieldName<TFieldValues>[] = [],\n    ) => {\n      const { errors } = await resolverRef.current!(\n        getFieldsValues(fieldsRef, defaultValuesRef),\n        contextRef.current,\n        {\n          criteriaMode,\n          names: currentNames,\n          fields: getFields(fieldsNamesRef.current, fieldsRef.current),\n        },\n      );\n\n      for (const name of names) {\n        const error = get(errors, name);\n        error\n          ? set(formStateRef.current.errors, name, error)\n          : unset(formStateRef.current.errors, name);\n      }\n\n      return errors;\n    },\n    [criteriaMode],\n  );\n\n  const validateForm = async (fieldsRef: FieldRefs) => {\n    for (const name in fieldsRef) {\n      const field = fieldsRef[name];\n\n      if (field) {\n        const _f = field._f;\n        const current = omit(field, '_f');\n\n        if (_f) {\n          const fieldError = await validateField(\n            field,\n            isValidateAllFieldCriteria,\n          );\n\n          if (fieldError[_f.name]) {\n            set(formStateRef.current.errors, _f.name, fieldError[_f.name]);\n            unset(validFieldsRef.current, _f.name);\n          } else if (get(fieldsWithValidationRef.current, _f.name)) {\n            set(validFieldsRef.current, _f.name, true);\n            unset(formStateRef.current.errors, _f.name);\n          }\n        }\n\n        current && (await validateForm(current));\n      }\n    }\n  };\n\n  const trigger: UseFormTrigger<TFieldValues> = React.useCallback(\n    async (name) => {\n      const fields = isUndefined(name)\n        ? Object.keys(fieldsRef.current)\n        : Array.isArray(name)\n        ? name\n        : [name];\n      let isValid;\n\n      formStateSubjectRef.current.next({\n        isValidating: true,\n      });\n\n      if (resolverRef.current) {\n        isValid = isEmptyObject(\n          await executeSchemaOrResolverValidation(\n            fields,\n            isUndefined(name)\n              ? undefined\n              : (fields as FieldName<TFieldValues>[]),\n          ),\n        );\n      } else {\n        isUndefined(name)\n          ? await validateForm(fieldsRef.current)\n          : await Promise.all(\n              fields.map(async (data) => await executeValidation(data, null)),\n            );\n      }\n\n      formStateSubjectRef.current.next({\n        errors: formStateRef.current.errors,\n        isValidating: false,\n        isValid: resolverRef.current ? isValid : getIsValid(),\n      });\n    },\n    [executeSchemaOrResolverValidation, executeValidation],\n  );\n\n  const setInternalValues = React.useCallback(\n    (\n      name: FieldPath<TFieldValues>,\n      value: UnpackNestedValue<\n        PathValue<TFieldValues, FieldPath<TFieldValues>>\n      >,\n      options: SetValueConfig,\n    ) =>\n      Object.entries(value).forEach(([inputKey, inputValue]) => {\n        const fieldName = `${name}.${inputKey}` as Path<TFieldValues>;\n        const field = get(fieldsRef.current, fieldName);\n\n        field && !field._f\n          ? setInternalValues(\n              fieldName,\n              inputValue as SetFieldValue<TFieldValues>,\n              options,\n            )\n          : setFieldValue(\n              fieldName,\n              inputValue as SetFieldValue<TFieldValues>,\n              options,\n              true,\n              !field,\n            );\n      }),\n    [trigger],\n  );\n\n  const isFieldWatched = (name: FieldPath<TFieldValues>) =>\n    isWatchAllRef.current ||\n    watchFieldsRef.current.has(name) ||\n    watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const updateValidAndValue = (\n    name: InternalFieldName,\n    options?: RegisterOptions,\n    isWithinRefCallback?: boolean,\n  ) => {\n    let defaultValue;\n    const field = get(fieldsRef.current, name) as Field;\n    const useFormDefaultValue = get(defaultValuesRef.current, name);\n\n    if (\n      field &&\n      (!isEmptyObject(defaultValuesRef.current) || !isUndefined(field._f.value))\n    ) {\n      defaultValue = isUndefined(field._f.value)\n        ? useFormDefaultValue\n        : field._f.value;\n\n      if (!isUndefined(defaultValue)) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    if (\n      (useFormDefaultValue || (!useFormDefaultValue && isWithinRefCallback)) &&\n      options &&\n      !validationMode.isOnSubmit &&\n      field &&\n      readFormStateRef.current.isValid\n    ) {\n      validateField(field, isValidateAllFieldCriteria).then((error) => {\n        isEmptyObject(error)\n          ? set(validFieldsRef.current, name, true)\n          : unset(validFieldsRef.current, name);\n\n        formStateRef.current.isValid &&\n          !isEmptyObject(error) &&\n          setFormState({ ...formStateRef.current, isValid: getIsValid() });\n      });\n    }\n\n    return defaultValue;\n  };\n\n  const setValue: UseFormSetValue<TFieldValues> = (\n    name,\n    value,\n    options = {},\n  ) => {\n    isMountedRef.current = true;\n    const field = get(fieldsRef.current, name);\n    const isFieldArray = fieldArrayNamesRef.current.has(name);\n\n    if (isFieldArray) {\n      fieldArraySubjectRef.current.next({\n        fields: value,\n        name,\n        isReset: true,\n      });\n\n      if (\n        (readFormStateRef.current.isDirty ||\n          readFormStateRef.current.dirtyFields) &&\n        options.shouldDirty\n      ) {\n        set(\n          formStateRef.current.dirtyFields,\n          name,\n          setFieldArrayDirtyFields(\n            value,\n            get(defaultValuesRef.current, name, []),\n            get(formStateRef.current.dirtyFields, name, []),\n          ),\n        );\n\n        formStateSubjectRef.current.next({\n          dirtyFields: formStateRef.current.dirtyFields,\n          isDirty: getFormIsDirty(name, value),\n        });\n      }\n\n      !(value as []).length &&\n        set(fieldsRef.current, name, []) &&\n        set(fieldArrayDefaultValuesRef.current, name, []);\n    }\n\n    (field && !field._f) || isFieldArray\n      ? setInternalValues(name, value, isFieldArray ? {} : options)\n      : setFieldValue(name, value, options, true, !field);\n\n    isFieldWatched(name) && formStateSubjectRef.current.next({});\n    watchSubjectRef.current.next({ name, value });\n  };\n\n  const handleChange: ChangeHandler = React.useCallback(\n    async ({ type, target, target: { value, type: inputType } }) => {\n      let name = (target as Ref)!.name;\n      let error;\n      let isValid;\n      const field = get(fieldsRef.current, name) as Field;\n\n      if (field) {\n        const inputValue = inputType ? getFieldValue(field) : value;\n        const isBlurEvent = type === EVENTS.BLUR;\n        const {\n          isOnBlur: isReValidateOnBlur,\n          isOnChange: isReValidateOnChange,\n        } = getValidationModes(reValidateMode);\n        const shouldSkipValidation = skipValidation({\n          isBlurEvent,\n          isTouched: !!get(formStateRef.current.touchedFields, name),\n          isSubmitted: formStateRef.current.isSubmitted,\n          isReValidateOnBlur,\n          isReValidateOnChange,\n          ...validationMode,\n        });\n        const isWatched =\n          !isBlurEvent && isFieldWatched(name as FieldPath<TFieldValues>);\n\n        if (!isUndefined(inputValue)) {\n          field._f.value = inputValue;\n        }\n\n        const state = updateAndGetDirtyState(name, field._f.value, false);\n\n        if (isBlurEvent && !get(formStateRef.current.touchedFields, name)) {\n          set(formStateRef.current.touchedFields, name, true);\n          readFormStateRef.current.touchedFields &&\n            (state.touchedFields = formStateRef.current.touchedFields);\n        }\n\n        let shouldRender = !isEmptyObject(state) || isWatched;\n\n        if (shouldSkipValidation) {\n          !isBlurEvent &&\n            watchSubjectRef.current.next({\n              name,\n              type,\n              value: inputValue,\n            });\n          return (\n            shouldRender &&\n            formStateSubjectRef.current.next(isWatched ? {} : state)\n          );\n        }\n\n        formStateSubjectRef.current.next({\n          isValidating: true,\n        });\n\n        if (resolverRef.current) {\n          const { errors } = await resolverRef.current(\n            getFieldsValues(fieldsRef, defaultValuesRef),\n            contextRef.current,\n            {\n              criteriaMode,\n              fields: getFields([name], fieldsRef.current),\n              names: [name as FieldName<TFieldValues>],\n            },\n          );\n          const previousFormIsValid = formStateRef.current.isValid;\n          error = get(errors, name);\n\n          if (isCheckBoxInput(target as Ref) && !error) {\n            const parentNodeName = getNodeParentName(name);\n            const currentError = get(errors, parentNodeName, {});\n            currentError.type && currentError.message && (error = currentError);\n\n            if (\n              currentError ||\n              get(formStateRef.current.errors, parentNodeName)\n            ) {\n              name = parentNodeName;\n            }\n          }\n\n          isValid = isEmptyObject(errors);\n\n          previousFormIsValid !== isValid && (shouldRender = true);\n        } else {\n          error = (await validateField(field, isValidateAllFieldCriteria))[\n            name\n          ];\n        }\n\n        !isBlurEvent &&\n          watchSubjectRef.current.next({\n            name,\n            type,\n            value: inputValue,\n          });\n        shouldRenderBaseOnError(\n          name,\n          error,\n          shouldRender,\n          state,\n          isValid,\n          isWatched,\n        );\n      }\n    },\n    [],\n  );\n\n  const getValues: UseFormGetValues<TFieldValues> = (\n    fieldNames?: FieldPath<TFieldValues> | FieldPath<TFieldValues>[],\n  ) => {\n    const values = isMountedRef.current\n      ? getFieldsValues(fieldsRef, defaultValuesRef)\n      : defaultValuesRef.current;\n\n    return isUndefined(fieldNames)\n      ? values\n      : isString(fieldNames)\n      ? get(values, fieldNames as InternalFieldName)\n      : fieldNames.map((name) => get(values, name as InternalFieldName));\n  };\n\n  const updateIsValid = React.useCallback(\n    async (values = {}) => {\n      const previousIsValid = formStateRef.current.isValid;\n\n      if (resolver) {\n        const { errors } = await resolverRef.current!(\n          {\n            ...getFieldsValues(fieldsRef, defaultValuesRef),\n            ...values,\n          },\n          contextRef.current,\n          {\n            criteriaMode,\n            fields: getFields(fieldsNamesRef.current, fieldsRef.current),\n          },\n        );\n        formStateRef.current.isValid = isEmptyObject(errors);\n      } else {\n        getIsValid();\n      }\n\n      previousIsValid !== formStateRef.current.isValid &&\n        formStateSubjectRef.current.next({\n          isValid: formStateRef.current.isValid,\n        });\n    },\n    [criteriaMode],\n  );\n\n  const clearErrors: UseFormClearErrors<TFieldValues> = (name) => {\n    name &&\n      (Array.isArray(name) ? name : [name]).forEach((inputName) =>\n        unset(formStateRef.current.errors, inputName),\n      );\n\n    formStateSubjectRef.current.next({\n      errors: name ? formStateRef.current.errors : {},\n    });\n  };\n\n  const setError: UseFormSetError<TFieldValues> = (name, error, options) => {\n    const ref = (\n      ((get(fieldsRef.current, name) as Field) || { _f: {} })._f || {}\n    ).ref;\n\n    set(formStateRef.current.errors, name, {\n      ...error,\n      ref,\n    });\n\n    formStateSubjectRef.current.next({\n      errors: formStateRef.current.errors,\n      isValid: false,\n    });\n\n    options && options.shouldFocus && ref && ref.focus && ref.focus();\n  };\n\n  const watchInternal: WatchInternal<TFieldValues> = React.useCallback(\n    (fieldNames, defaultValue, isGlobal) => {\n      const isArrayNames = Array.isArray(fieldNames);\n      const fieldValues = isMountedRef.current\n        ? getValues()\n        : isUndefined(defaultValue)\n        ? defaultValuesRef.current\n        : isArrayNames\n        ? defaultValue || {}\n        : { [fieldNames as string]: defaultValue };\n\n      if (isUndefined(fieldNames)) {\n        isGlobal && (isWatchAllRef.current = true);\n        return fieldValues;\n      }\n\n      const result = [];\n\n      for (const fieldName of isArrayNames ? fieldNames : [fieldNames]) {\n        isGlobal && watchFieldsRef.current.add(fieldName as string);\n        result.push(get(fieldValues, fieldName as string));\n      }\n\n      return isArrayNames ? result : result[0];\n    },\n    [],\n  );\n\n  const watch: UseFormWatch<TFieldValues> = (\n    fieldName?:\n      | FieldPath<TFieldValues>\n      | FieldPath<TFieldValues>[]\n      | WatchObserver<TFieldValues>,\n    defaultValue?: unknown,\n  ) =>\n    isFunction(fieldName)\n      ? watchSubjectRef.current.subscribe({\n          next: (info) =>\n            fieldName(\n              watchInternal(\n                undefined,\n                defaultValue as UnpackNestedValue<DeepPartial<TFieldValues>>,\n              ) as UnpackNestedValue<TFieldValues>,\n              info,\n            ),\n        })\n      : watchInternal(\n          fieldName as string | string[],\n          defaultValue as UnpackNestedValue<DeepPartial<TFieldValues>>,\n          true,\n        );\n\n  const unregister: UseFormUnregister<TFieldValues> = (name, options = {}) => {\n    for (const inputName of name\n      ? Array.isArray(name)\n        ? name\n        : [name]\n      : Object.keys(fieldsNamesRef.current)) {\n      fieldsNamesRef.current.delete(inputName);\n      fieldArrayNamesRef.current.delete(inputName);\n\n      if (get(fieldsRef.current, inputName) as Field) {\n        if (!options.keepIsValid) {\n          unset(fieldsWithValidationRef.current, inputName);\n          unset(validFieldsRef.current, inputName);\n        }\n        !options.keepError && unset(formStateRef.current.errors, inputName);\n        !options.keepValue && unset(fieldsRef.current, inputName);\n        !options.keepDirty &&\n          unset(formStateRef.current.dirtyFields, inputName);\n        !options.keepTouched &&\n          unset(formStateRef.current.touchedFields, inputName);\n        !options.keepDefaultValue && unset(defaultValuesRef.current, inputName);\n\n        watchSubjectRef.current.next({\n          name: inputName,\n        });\n      }\n    }\n\n    formStateSubjectRef.current.next({\n      ...formStateRef.current,\n      ...(!options.keepDirty ? {} : { isDirty: getFormIsDirty() }),\n      ...(resolverRef.current ? {} : { isValid: getIsValid() }),\n    });\n\n    if (!options.keepIsValid) {\n      updateIsValid();\n    }\n  };\n\n  const registerFieldRef = (\n    name: InternalFieldName,\n    ref: HTMLInputElement,\n    options?: RegisterOptions,\n  ): ((name: InternalFieldName) => void) | void => {\n    let field = get(fieldsRef.current, name) as Field;\n\n    if (field) {\n      const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n\n      if (\n        (isRadioOrCheckbox\n          ? Array.isArray(field._f.refs) &&\n            compact(field._f.refs).find(\n              (option) => ref.value === option.value && option === ref,\n            )\n          : ref === field._f.ref) ||\n        !field ||\n        (isWeb && isHTMLElement(field._f.ref) && !isHTMLElement(ref))\n      ) {\n        return;\n      }\n\n      field = {\n        _f: isRadioOrCheckbox\n          ? {\n              ...field._f,\n              refs: [\n                ...compact(field._f.refs || []).filter(\n                  (ref) => isHTMLElement(ref) && document.contains(ref),\n                ),\n                ref,\n              ],\n              ref: { type: ref.type, name },\n            }\n          : {\n              ...field._f,\n              ref,\n            },\n      };\n\n      set(fieldsRef.current, name, field);\n\n      const defaultValue = updateValidAndValue(name, options, true);\n\n      if (\n        isRadioOrCheckbox && Array.isArray(defaultValue)\n          ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue)\n          : isUndefined(get(fieldsRef.current, name)._f.value)\n      ) {\n        get(fieldsRef.current, name)._f.value = getFieldValue(\n          get(fieldsRef.current, name),\n        );\n      }\n    }\n  };\n\n  const register: UseFormRegister<TFieldValues> = React.useCallback(\n    (name, options) => {\n      const isInitialRegister = !get(fieldsRef.current, name);\n\n      set(fieldsRef.current, name, {\n        _f: {\n          ...(isInitialRegister\n            ? { ref: { name } }\n            : {\n                ref: (get(fieldsRef.current, name)._f || {}).ref,\n                ...get(fieldsRef.current, name)._f,\n              }),\n          name,\n          ...options,\n        },\n      });\n      options && set(fieldsWithValidationRef.current, name, true);\n      fieldsNamesRef.current.add(name);\n      isInitialRegister && updateValidAndValue(name, options);\n\n      return isWindowUndefined\n        ? ({ name: name as InternalFieldName } as UseFormRegisterReturn)\n        : {\n            name,\n            onChange: handleChange,\n            onBlur: handleChange,\n            ref: (ref: HTMLInputElement | null) =>\n              ref && registerFieldRef(name, ref, options),\n          };\n    },\n    [defaultValuesRef.current],\n  );\n\n  const handleSubmit: UseFormHandleSubmit<TFieldValues> = React.useCallback(\n    (onValid, onInvalid) => async (e) => {\n      if (e && e.preventDefault) {\n        e.preventDefault();\n        e.persist();\n      }\n      let fieldValues = {\n        ...defaultValuesRef.current,\n        ...getFieldsValues(fieldsRef, defaultValuesRef),\n      };\n\n      formStateSubjectRef.current.next({\n        isSubmitting: true,\n      });\n\n      try {\n        if (resolverRef.current) {\n          const { errors, values } = await resolverRef.current(\n            fieldValues,\n            contextRef.current,\n            {\n              criteriaMode,\n              fields: getFields(fieldsNamesRef.current, fieldsRef.current),\n            },\n          );\n          formStateRef.current.errors = errors;\n          fieldValues = values;\n        } else {\n          await validateForm(fieldsRef.current);\n        }\n\n        if (\n          isEmptyObject(formStateRef.current.errors) &&\n          Object.keys(formStateRef.current.errors).every((name) =>\n            get(fieldValues, name),\n          )\n        ) {\n          formStateSubjectRef.current.next({\n            errors: {},\n            isSubmitting: true,\n          });\n          await onValid(fieldValues, e);\n        } else {\n          onInvalid && (await onInvalid(formStateRef.current.errors, e));\n          shouldFocusError &&\n            focusFieldBy(\n              fieldsRef.current,\n              (key: string) => get(formStateRef.current.errors, key),\n              fieldsNamesRef.current,\n            );\n        }\n      } finally {\n        formStateRef.current.isSubmitted = true;\n        formStateSubjectRef.current.next({\n          isSubmitted: true,\n          isSubmitting: false,\n          isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n          submitCount: formStateRef.current.submitCount + 1,\n          errors: formStateRef.current.errors,\n        });\n      }\n    },\n    [shouldFocusError, isValidateAllFieldCriteria, criteriaMode],\n  );\n\n  const resetFromState = React.useCallback(\n    ({\n      keepErrors,\n      keepDirty,\n      keepIsSubmitted,\n      keepTouched,\n      keepIsValid,\n      keepSubmitCount,\n    }: KeepStateOptions) => {\n      if (!keepIsValid) {\n        validFieldsRef.current = {};\n        fieldsWithValidationRef.current = {};\n      }\n\n      watchFieldsRef.current = new Set();\n      isWatchAllRef.current = false;\n\n      formStateSubjectRef.current.next({\n        submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\n        isDirty: keepDirty ? formStateRef.current.isDirty : false,\n        isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\n        isValid: keepIsValid\n          ? formStateRef.current.isValid\n          : !validationMode.isOnSubmit,\n        dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\n        touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\n        errors: keepErrors ? formStateRef.current.errors : {},\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n      });\n    },\n    [],\n  );\n\n  const reset: UseFormReset<TFieldValues> = (values, keepStateOptions = {}) => {\n    const updatedValues = values || defaultValuesRef.current;\n\n    if (isWeb && !keepStateOptions.keepValues) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field && field._f) {\n          const inputRef = Array.isArray(field._f.refs)\n            ? field._f.refs[0]\n            : field._f.ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form')!.reset();\n              break;\n            } catch {}\n          }\n        }\n      }\n    }\n\n    !keepStateOptions.keepDefaultValues &&\n      (defaultValuesRef.current = { ...updatedValues });\n\n    if (!keepStateOptions.keepValues) {\n      fieldsRef.current = {};\n\n      controllerSubjectRef.current.next({\n        values: { ...updatedValues },\n      });\n\n      watchSubjectRef.current.next({\n        value: { ...updatedValues },\n      });\n\n      fieldArraySubjectRef.current.next({\n        fields: { ...updatedValues },\n        isReset: true,\n      });\n    }\n\n    resetFromState(keepStateOptions);\n  };\n\n  React.useEffect(() => {\n    isMountedRef.current = true;\n    const formStateSubscription = formStateSubjectRef.current.subscribe({\n      next(formState: Partial<FormState<TFieldValues>> = {}) {\n        if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\n          formStateRef.current = {\n            ...formStateRef.current,\n            ...formState,\n          };\n          setFormState(formStateRef.current);\n        }\n      },\n    });\n\n    const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\n      next(state) {\n        if (state.fields && state.name && readFormStateRef.current.isValid) {\n          const values = getFieldsValues(fieldsRef);\n          set(values, state.name, state.fields);\n          updateIsValid(values);\n        }\n      },\n    });\n\n    resolverRef.current && readFormStateRef.current.isValid && updateIsValid();\n\n    return () => {\n      watchSubjectRef.current.unsubscribe();\n      formStateSubscription.unsubscribe();\n      useFieldArraySubscription.unsubscribe();\n    };\n  }, []);\n\n  return {\n    control: React.useMemo(\n      () => ({\n        register,\n        isWatchAllRef,\n        watchFieldsRef,\n        getFormIsDirty,\n        formStateSubjectRef,\n        fieldArraySubjectRef,\n        controllerSubjectRef,\n        watchSubjectRef,\n        watchInternal,\n        fieldsRef,\n        validFieldsRef,\n        fieldsWithValidationRef,\n        fieldArrayNamesRef,\n        readFormStateRef,\n        formStateRef,\n        defaultValuesRef,\n        fieldArrayDefaultValuesRef,\n      }),\n      [],\n    ),\n    formState: getProxyFormState<TFieldValues>(\n      isProxyEnabled,\n      formState,\n      readFormStateRef,\n    ),\n    trigger,\n    register,\n    handleSubmit,\n    watch: React.useCallback(watch, []),\n    setValue: React.useCallback(setValue, [setInternalValues]),\n    getValues: React.useCallback(getValues, []),\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    unregister: React.useCallback(unregister, []),\n    setError: React.useCallback(setError, []),\n  };\n}\n","import * as React from 'react';\n\nimport isString from './utils/isString';\nimport isUndefined from './utils/isUndefined';\nimport {\n  Control,\n  DeepPartial,\n  FieldPath,\n  FieldPathValue,\n  FieldPathValues,\n  FieldValues,\n  InternalFieldName,\n  UnpackNestedValue,\n  UseWatchProps,\n} from './types';\nimport { useFormContext } from './useFormContext';\n\nexport function useWatch<\n  TFieldValues extends FieldValues = FieldValues\n>(props: {\n  defaultValue?: UnpackNestedValue<DeepPartial<TFieldValues>>;\n  control?: Control<TFieldValues>;\n}): UnpackNestedValue<DeepPartial<TFieldValues>>;\nexport function useWatch<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>(props: {\n  name: TName;\n  defaultValue?: FieldPathValue<TFieldValues, TName>;\n  control?: Control<TFieldValues>;\n}): FieldPathValue<TFieldValues, TName>;\nexport function useWatch<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues>[] = FieldPath<TFieldValues>[]\n>(props: {\n  name: TName;\n  defaultValue?: UnpackNestedValue<DeepPartial<TFieldValues>>;\n  control?: Control<TFieldValues>;\n}): FieldPathValues<TFieldValues, TName>;\nexport function useWatch<TFieldValues>(props?: UseWatchProps<TFieldValues>) {\n  const { control, name, defaultValue } = props || {};\n  const methods = useFormContext();\n  const nameRef = React.useRef(name);\n  nameRef.current = name;\n\n  const { watchInternal, watchSubjectRef } = control || methods.control;\n  const [value, updateValue] = React.useState<unknown>(\n    isUndefined(defaultValue)\n      ? watchInternal(name as InternalFieldName)\n      : defaultValue,\n  );\n\n  React.useEffect(() => {\n    watchInternal(name as InternalFieldName);\n\n    const watchSubscription = watchSubjectRef.current.subscribe({\n      next: ({ name: inputName, value }) =>\n        (!nameRef.current ||\n          !inputName ||\n          (Array.isArray(nameRef.current)\n            ? nameRef.current\n            : [nameRef.current]\n          ).some(\n            (fieldName) =>\n              inputName &&\n              fieldName &&\n              inputName.startsWith(fieldName as InternalFieldName),\n          )) &&\n        updateValue(\n          isString(inputName) &&\n            nameRef.current === inputName &&\n            !isUndefined(value)\n            ? value\n            : watchInternal(\n                nameRef.current as string,\n                defaultValue as UnpackNestedValue<DeepPartial<TFieldValues>>,\n              ),\n        ),\n    });\n\n    return () => watchSubscription.unsubscribe();\n  }, []);\n\n  return value;\n}\n"]},"metadata":{},"sourceType":"module"}